<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>the Geocomputation with R website</title>
    <link>/feed.xml</link>
    <description>Recent content on the Geocomputation with R website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Apr 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Demo of reproducible geographic data analysis: mapping Covid-19 data with R</title>
      <link>/post/2020/mapping-covid-19/</link>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/mapping-covid-19/</guid>
      <description>


&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 7.0.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tmap)
library(dplyr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get data on official Covid-19 statistics, we will use the &lt;a href=&#34;https://github.com/covid19datahub/COVID19&#34;&gt;&lt;code&gt;COVID19&lt;/code&gt;&lt;/a&gt; R package.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/b627e2aa6edcee3ead77511a35d4e1a5e91aa07f/68747470733a2f2f73746f726167652e636f7669643139646174616875622e696f2f6c6f676f2e737667&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This package provides daily updated data on a variety of variables related to the coronavirus pandemic at national, regional and city levels.
Install it as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;COVID19&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To minimise dependencies for reproducing the results in this article, we accessed and uploaded a copy of the data with the following commands:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d = COVID19::covid19()
readr::write_csv(d, paste0(&amp;quot;COVID19-data-&amp;quot;, Sys.Date(), &amp;quot;.csv&amp;quot;))
piggyback::pb_upload(paste0(&amp;quot;COVID19-data-&amp;quot;, Sys.Date(), &amp;quot;.csv&amp;quot;), repo = &amp;quot;robinlovelace/geocompr&amp;quot;)
piggyback::pb_download_url(paste0(&amp;quot;COVID19-data-&amp;quot;, Sys.Date(), &amp;quot;.csv&amp;quot;), repo = &amp;quot;robinlovelace/geocompr&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Read-in the Covid19 data from the date this post was written as follows (re-run the code above to get up-to-date data):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d = readr::read_csv(&amp;quot;https://github.com/Robinlovelace/geocompr/releases/download/1.2/COVID19-data-2020-04-22.csv&amp;quot;)
class(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;spec_tbl_df&amp;quot; &amp;quot;tbl_df&amp;quot;      &amp;quot;tbl&amp;quot;         &amp;quot;data.frame&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ncol(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nrow(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 17572&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;id&amp;quot;             &amp;quot;date&amp;quot;           &amp;quot;deaths&amp;quot;         &amp;quot;confirmed&amp;quot;     
##  [5] &amp;quot;tests&amp;quot;          &amp;quot;recovered&amp;quot;      &amp;quot;hosp&amp;quot;           &amp;quot;icu&amp;quot;           
##  [9] &amp;quot;vent&amp;quot;           &amp;quot;driving&amp;quot;        &amp;quot;walking&amp;quot;        &amp;quot;transit&amp;quot;       
## [13] &amp;quot;country&amp;quot;        &amp;quot;state&amp;quot;          &amp;quot;city&amp;quot;           &amp;quot;lat&amp;quot;           
## [17] &amp;quot;lng&amp;quot;            &amp;quot;pop&amp;quot;            &amp;quot;pop_14&amp;quot;         &amp;quot;pop_15_64&amp;quot;     
## [21] &amp;quot;pop_65&amp;quot;         &amp;quot;pop_age&amp;quot;        &amp;quot;pop_density&amp;quot;    &amp;quot;pop_death_rate&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [90m# A tibble: 6 x 24[39m
##   id    date       deaths confirmed tests recovered  hosp   icu  vent driving
##   [3m[90m&amp;lt;chr&amp;gt;[39m[23m [3m[90m&amp;lt;date&amp;gt;[39m[23m      [3m[90m&amp;lt;dbl&amp;gt;[39m[23m     [3m[90m&amp;lt;dbl&amp;gt;[39m[23m [3m[90m&amp;lt;dbl&amp;gt;[39m[23m     [3m[90m&amp;lt;dbl&amp;gt;[39m[23m [3m[90m&amp;lt;dbl&amp;gt;[39m[23m [3m[90m&amp;lt;dbl&amp;gt;[39m[23m [3m[90m&amp;lt;dbl&amp;gt;[39m[23m   [3m[90m&amp;lt;dbl&amp;gt;[39m[23m
## [90m1[39m AFG   2020-01-22      0         0     0         0     0     0     0       0
## [90m2[39m AFG   2020-01-23      0         0     0         0     0     0     0       0
## [90m3[39m AFG   2020-01-24      0         0     0         0     0     0     0       0
## [90m4[39m AFG   2020-01-25      0         0     0         0     0     0     0       0
## [90m5[39m AFG   2020-01-26      0         0     0         0     0     0     0       0
## [90m6[39m AFG   2020-01-27      0         0     0         0     0     0     0       0
## [90m# â€¦ with 14 more variables: walking [3m[90m&amp;lt;dbl&amp;gt;[90m[23m, transit [3m[90m&amp;lt;dbl&amp;gt;[90m[23m, country [3m[90m&amp;lt;chr&amp;gt;[90m[23m,[39m
## [90m#   state [3m[90m&amp;lt;lgl&amp;gt;[90m[23m, city [3m[90m&amp;lt;lgl&amp;gt;[90m[23m, lat [3m[90m&amp;lt;dbl&amp;gt;[90m[23m, lng [3m[90m&amp;lt;dbl&amp;gt;[90m[23m, pop [3m[90m&amp;lt;dbl&amp;gt;[90m[23m, pop_14 [3m[90m&amp;lt;dbl&amp;gt;[90m[23m,[39m
## [90m#   pop_15_64 [3m[90m&amp;lt;dbl&amp;gt;[90m[23m, pop_65 [3m[90m&amp;lt;dbl&amp;gt;[90m[23m, pop_age [3m[90m&amp;lt;dbl&amp;gt;[90m[23m, pop_density [3m[90m&amp;lt;dbl&amp;gt;[90m[23m,[39m
## [90m#   pop_death_rate [3m[90m&amp;lt;dbl&amp;gt;[90m[23m[39m&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world_rnatural = rnaturalearth::ne_download(returnclass = &amp;quot;sf&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## OGR data source with driver: ESRI Shapefile 
## Source: &amp;quot;/tmp/RtmpSqZ1sW&amp;quot;, layer: &amp;quot;ne_110m_admin_0_countries&amp;quot;
## with 177 features
## It has 94 fields
## Integer64 fields read as strings:  POP_EST NE_ID&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;unique(d$country[!d$id %in% world_rnatural$ISO_A3_EH])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Andorra&amp;quot;                          &amp;quot;American Samoa&amp;quot;                  
##  [3] &amp;quot;Antigua and Barbuda&amp;quot;              &amp;quot;Bahrain&amp;quot;                         
##  [5] &amp;quot;Barbados&amp;quot;                         &amp;quot;Cape Verde&amp;quot;                      
##  [7] &amp;quot;Dominica&amp;quot;                         &amp;quot;Diamond Princess&amp;quot;                
##  [9] &amp;quot;Grand Princess&amp;quot;                   &amp;quot;Grenada&amp;quot;                         
## [11] &amp;quot;Guam&amp;quot;                             &amp;quot;Saint Kitts and Nevis&amp;quot;           
## [13] &amp;quot;Saint Lucia&amp;quot;                      &amp;quot;Liechtenstein&amp;quot;                   
## [15] &amp;quot;Monaco&amp;quot;                           &amp;quot;Maldives&amp;quot;                        
## [17] &amp;quot;Malta&amp;quot;                            &amp;quot;Northern Mariana Islands&amp;quot;        
## [19] &amp;quot;MS Zaandam&amp;quot;                       &amp;quot;Mauritius&amp;quot;                       
## [21] &amp;quot;Norway&amp;quot;                           &amp;quot;Kosovo&amp;quot;                          
## [23] &amp;quot;Singapore&amp;quot;                        &amp;quot;San Marino&amp;quot;                      
## [25] &amp;quot;Sao Tome and Principe&amp;quot;            &amp;quot;Seychelles&amp;quot;                      
## [27] &amp;quot;Holy See&amp;quot;                         &amp;quot;Saint Vincent and the Grenadines&amp;quot;
## [29] &amp;quot;Virgin Islands, U.S.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;unique(world_rnatural$NAME[!world_rnatural$ISO_A3_EH %in% d$id])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Falkland Is.&amp;quot;           &amp;quot;Norway&amp;quot;                 &amp;quot;Greenland&amp;quot;             
##  [4] &amp;quot;Fr. S. Antarctic Lands&amp;quot; &amp;quot;Lesotho&amp;quot;                &amp;quot;Vanuatu&amp;quot;               
##  [7] &amp;quot;North Korea&amp;quot;            &amp;quot;Tajikistan&amp;quot;             &amp;quot;Turkmenistan&amp;quot;          
## [10] &amp;quot;New Caledonia&amp;quot;          &amp;quot;Solomon Is.&amp;quot;            &amp;quot;Antarctica&amp;quot;            
## [13] &amp;quot;N. Cyprus&amp;quot;              &amp;quot;Somaliland&amp;quot;             &amp;quot;Kosovo&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d %&amp;gt;% select(id, country) %&amp;gt;% filter(country == &amp;quot;France&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [90m# A tibble: 92 x 2[39m
##    id    country
##    [3m[90m&amp;lt;chr&amp;gt;[39m[23m [3m[90m&amp;lt;chr&amp;gt;[39m[23m  
## [90m 1[39m FRA   France 
## [90m 2[39m FRA   France 
## [90m 3[39m FRA   France 
## [90m 4[39m FRA   France 
## [90m 5[39m FRA   France 
## [90m 6[39m FRA   France 
## [90m 7[39m FRA   France 
## [90m 8[39m FRA   France 
## [90m 9[39m FRA   France 
## [90m10[39m FRA   France 
## [90m# â€¦ with 82 more rows[39m&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world_rnatural %&amp;gt;% select(ISO_A3_EH, NAME_LONG) %&amp;gt;% filter(NAME_LONG == &amp;quot;France&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 1 feature and 2 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -54.52475 ymin: 2.053389 xmax: 9.560016 ymax: 51.14851
## CRS:            +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0
##   ISO_A3_EH NAME_LONG                       geometry
## 1       FRA    France MULTIPOLYGON (((-51.6578 4....&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(world_rnatural)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world_projected = world_rnatural %&amp;gt;% 
  st_transform(&amp;quot;+proj=moll&amp;quot;)
plot(world_projected)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-5-2.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;w = dplyr::left_join(world_projected, d, by = c(&amp;quot;ISO_A3_EH&amp;quot;= &amp;quot;id&amp;quot;))
w_today = w[w$date == Sys.Date() - 1, ]
plot(w_today)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(w_today[&amp;quot;deaths&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b = c(0, 10, 100, 1000, 10000, 100000)
plot(w_today[&amp;quot;deaths&amp;quot;], breaks = b)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-7-2.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;w_today %&amp;gt;%
  dplyr::select(deaths, confirmed, tests, recovered) %&amp;gt;% 
  plot()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-7-3.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# w_today %&amp;gt;% filter(ISO_A2 == &amp;quot;US&amp;quot;) # check data for us&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(w_today) +
  tm_polygons(c(&amp;quot;deaths&amp;quot;, &amp;quot;recovered&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(w_today) +
  tm_polygons(c(&amp;quot;deaths&amp;quot;, &amp;quot;recovered&amp;quot;), palette = &amp;quot;viridis&amp;quot;, style = &amp;quot;log10_pretty&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g = st_graticule(w_today)
tm_shape(g) +
  tm_lines(col = &amp;quot;grey&amp;quot;) +
  tm_shape(w_today) +
  tm_polygons(
    c(&amp;quot;deaths&amp;quot;, &amp;quot;recovered&amp;quot;),
    palette = &amp;quot;viridis&amp;quot;,
    style = &amp;quot;log10_pretty&amp;quot;
    ) +
  tm_layout(legend.position = c(0.01, 0.25))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(g) +
  tm_lines(col = &amp;quot;grey&amp;quot;) +
  tm_shape(w_today) +
  tm_polygons(c(&amp;quot;deaths&amp;quot;, &amp;quot;recovered&amp;quot;), palette = &amp;quot;viridis&amp;quot;) +
  tm_layout(legend.position = c(0.01, 0.25)) +
  tm_shape(w_today) +
  tm_dots(size = c(&amp;quot;deaths&amp;quot;, &amp;quot;recovered&amp;quot;), col = c(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/r-spatial-demo-covid-19_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;w$Date = as.character(w$date)
tm_shape(g) +
  tm_lines(col = &amp;quot;grey&amp;quot;) +
  tm_shape(w_today) +
  tm_polygons(c(&amp;quot;deaths&amp;quot;), palette = &amp;quot;viridis&amp;quot;) +
  tm_layout(legend.position = c(0.01, 0.25)) +
  tm_shape(w %&amp;gt;% filter(date &amp;gt; Sys.Date() - 4)) +
  tm_dots(size = c(&amp;quot;deaths&amp;quot;), col = c(&amp;quot;red&amp;quot;)) +
  tm_facets(&amp;quot;Date&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To create an animated map, following instructions in Chapter &lt;a href=&#34;https://geocompr.robinlovelace.net/adv-map.html#animated-maps&#34;&gt;8&lt;/a&gt; of &lt;em&gt;Geocomputation with R&lt;/em&gt;, we need to make some small changes to the code above:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;m = tm_shape(g) +
  tm_lines(col = &amp;quot;grey&amp;quot;) +
  tm_shape(w_today) +
  tm_polygons(c(&amp;quot;deaths&amp;quot;), palette = &amp;quot;viridis&amp;quot;) +
  tm_layout(legend.position = c(0.01, 0.25)) +
  tm_shape(w %&amp;gt;% filter(date &amp;gt; Sys.Date() - 4)) +
  tm_dots(size = c(&amp;quot;deaths&amp;quot;), col = c(&amp;quot;red&amp;quot;)) +
  tm_facets(along = &amp;quot;Date&amp;quot;, free.coords = FALSE)
tmap_animation(m, &amp;quot;covid-19-animated-map-test.gif&amp;quot;, width = 800)
browseURL(&amp;quot;covid-19-animated-map-test.gif&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not bad, but would benefit from a few adjustments before we plot the results of the whole dataset:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world_projected$Area_km = as.numeric(st_area(world_projected)) / 1e6
world_projected$`Pop/km2` = as.numeric(world_projected$POP_EST) / world_projected$Area_km 
b = c(0, 100, 200, 400, 800, 16000)

m = tm_shape(g) +
  tm_lines(col = &amp;quot;grey&amp;quot;) +
  tm_shape(world_projected) +
  tm_polygons(&amp;quot;Pop/km2&amp;quot;, palette = &amp;quot;viridis&amp;quot;, breaks = b) +
  tm_layout(legend.position = c(0.01, 0.25)) +
  tm_shape(w %&amp;gt;% filter(date &amp;gt; Sys.Date() - 60)) +
  tm_dots(size = c(&amp;quot;deaths&amp;quot;), col = c(&amp;quot;red&amp;quot;)) +
  tm_facets(along = &amp;quot;Date&amp;quot;, free.coords = FALSE) +
  tm_layout(legend.outside = TRUE)
tmap_animation(m, &amp;quot;covid-19-animated-map.gif&amp;quot;, width = 1200)
browseURL(&amp;quot;covid-19-animated-map.gif&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1825120/79768034-1e60ab80-8322-11ea-9c99-9997b588ee57.gif&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## â”€ Session info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
##  setting  value                       
##  version  R version 3.6.3 (2020-02-29)
##  os       Ubuntu 18.04.4 LTS          
##  system   x86_64, linux-gnu           
##  ui       X11                         
##  language (EN)                        
##  collate  C.UTF-8                     
##  ctype    C.UTF-8                     
##  tz       UTC                         
##  date     2020-04-22                  
## 
## â”€ Packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
##  package       * version  date       lib source                              
##  abind           1.4-5    2016-07-21 [1] CRAN (R 3.6.3)                      
##  assertthat      0.2.1    2019-03-21 [1] CRAN (R 3.6.3)                      
##  backports       1.1.6    2020-04-05 [1] CRAN (R 3.6.3)                      
##  base64enc       0.1-3    2015-07-28 [1] CRAN (R 3.6.3)                      
##  blogdown        0.18.1   2020-04-22 [1] Github (rstudio/blogdown@8ff1fad)   
##  bookdown        0.18.1   2020-04-22 [1] Github (rstudio/bookdown@cd97d40)   
##  callr           3.4.3    2020-03-28 [1] CRAN (R 3.6.3)                      
##  class           7.3-15   2019-01-01 [2] CRAN (R 3.6.3)                      
##  classInt        0.4-3    2020-04-07 [1] CRAN (R 3.6.3)                      
##  cli             2.0.2    2020-02-28 [1] CRAN (R 3.6.3)                      
##  codetools       0.2-16   2018-12-24 [2] CRAN (R 3.6.3)                      
##  colorspace      1.4-1    2019-03-18 [1] CRAN (R 3.6.3)                      
##  crayon          1.3.4    2017-09-16 [1] CRAN (R 3.6.3)                      
##  crosstalk       1.1.0.1  2020-03-13 [1] CRAN (R 3.6.3)                      
##  curl            4.3      2019-12-02 [1] CRAN (R 3.6.3)                      
##  DBI             1.1.0    2019-12-15 [1] CRAN (R 3.6.3)                      
##  desc            1.2.0    2018-05-01 [1] CRAN (R 3.6.3)                      
##  devtools        2.3.0    2020-04-10 [1] CRAN (R 3.6.3)                      
##  dichromat       2.0-0    2013-01-24 [1] CRAN (R 3.6.3)                      
##  digest          0.6.25   2020-02-23 [1] CRAN (R 3.6.3)                      
##  dplyr         * 0.8.5    2020-03-07 [1] CRAN (R 3.6.3)                      
##  e1071           1.7-3    2019-11-26 [1] CRAN (R 3.6.3)                      
##  ellipsis        0.3.0    2019-09-20 [1] CRAN (R 3.6.3)                      
##  evaluate        0.14     2019-05-28 [1] CRAN (R 3.6.3)                      
##  fansi           0.4.1    2020-01-08 [1] CRAN (R 3.6.3)                      
##  fs              1.4.1    2020-04-04 [1] CRAN (R 3.6.3)                      
##  glue            1.4.0    2020-04-03 [1] CRAN (R 3.6.3)                      
##  hms             0.5.3    2020-01-08 [1] CRAN (R 3.6.3)                      
##  htmltools       0.4.0    2019-10-04 [1] CRAN (R 3.6.3)                      
##  htmlwidgets     1.5.1    2019-10-08 [1] CRAN (R 3.6.3)                      
##  KernSmooth      2.23-16  2019-10-15 [2] CRAN (R 3.6.3)                      
##  knitr           1.28     2020-02-06 [1] CRAN (R 3.6.3)                      
##  lattice         0.20-38  2018-11-04 [2] CRAN (R 3.6.3)                      
##  leafem          0.1.1    2020-04-05 [1] CRAN (R 3.6.3)                      
##  leaflet         2.0.3    2019-11-16 [1] CRAN (R 3.6.3)                      
##  leafsync        0.1.0    2019-03-05 [1] CRAN (R 3.6.3)                      
##  lifecycle       0.2.0    2020-03-06 [1] CRAN (R 3.6.3)                      
##  lwgeom          0.2-3    2020-04-12 [1] CRAN (R 3.6.3)                      
##  magrittr        1.5      2014-11-22 [1] CRAN (R 3.6.3)                      
##  memoise         1.1.0    2017-04-21 [1] CRAN (R 3.6.3)                      
##  munsell         0.5.0    2018-06-12 [1] CRAN (R 3.6.3)                      
##  pillar          1.4.3    2019-12-20 [1] CRAN (R 3.6.3)                      
##  pkgbuild        1.0.6    2019-10-09 [1] CRAN (R 3.6.3)                      
##  pkgconfig       2.0.3    2019-09-22 [1] CRAN (R 3.6.3)                      
##  pkgload         1.0.2    2018-10-29 [1] CRAN (R 3.6.3)                      
##  png             0.1-7    2013-12-03 [1] CRAN (R 3.6.3)                      
##  prettyunits     1.1.1    2020-01-24 [1] CRAN (R 3.6.3)                      
##  processx        3.4.2    2020-02-09 [1] CRAN (R 3.6.3)                      
##  ps              1.3.2    2020-02-13 [1] CRAN (R 3.6.3)                      
##  purrr           0.3.4    2020-04-17 [1] CRAN (R 3.6.3)                      
##  R6              2.4.1    2019-11-12 [1] CRAN (R 3.6.3)                      
##  raster          3.1-5    2020-04-19 [1] CRAN (R 3.6.3)                      
##  RColorBrewer    1.1-2    2014-12-07 [1] CRAN (R 3.6.3)                      
##  Rcpp            1.0.4.6  2020-04-09 [1] CRAN (R 3.6.3)                      
##  readr           1.3.1    2018-12-21 [1] CRAN (R 3.6.3)                      
##  remotes         2.1.1    2020-02-15 [1] CRAN (R 3.6.3)                      
##  rgdal           1.4-8    2019-11-27 [1] CRAN (R 3.6.3)                      
##  rlang           0.4.5    2020-03-01 [1] CRAN (R 3.6.3)                      
##  rmarkdown       2.1      2020-01-20 [1] CRAN (R 3.6.3)                      
##  rnaturalearth   0.1.0    2017-03-21 [1] CRAN (R 3.6.3)                      
##  rprojroot       1.3-2    2018-01-03 [1] CRAN (R 3.6.3)                      
##  scales          1.1.0    2019-11-18 [1] CRAN (R 3.6.3)                      
##  sessioninfo     1.1.1    2018-11-05 [1] CRAN (R 3.6.3)                      
##  sf            * 0.9-2    2020-04-14 [1] CRAN (R 3.6.3)                      
##  sp              1.4-1    2020-02-28 [1] CRAN (R 3.6.3)                      
##  stars           0.4-1    2020-04-07 [1] CRAN (R 3.6.3)                      
##  stringi         1.4.6    2020-02-17 [1] CRAN (R 3.6.3)                      
##  stringr         1.4.0    2019-02-10 [1] CRAN (R 3.6.3)                      
##  testthat        2.3.2    2020-03-02 [1] CRAN (R 3.6.3)                      
##  tibble          3.0.1    2020-04-20 [1] CRAN (R 3.6.3)                      
##  tidyselect      1.0.0    2020-01-27 [1] CRAN (R 3.6.3)                      
##  tmap          * 3.0      2020-04-22 [1] Github (mtennekes/tmap@4a9249a)     
##  tmaptools       3.0-1    2020-04-22 [1] Github (mtennekes/tmaptools@adbf1da)
##  units           0.6-6    2020-03-16 [1] CRAN (R 3.6.3)                      
##  usethis         1.6.0    2020-04-09 [1] CRAN (R 3.6.3)                      
##  utf8            1.1.4    2018-05-24 [1] CRAN (R 3.6.3)                      
##  vctrs           0.2.4    2020-03-10 [1] CRAN (R 3.6.3)                      
##  viridisLite     0.3.0    2018-02-01 [1] CRAN (R 3.6.3)                      
##  withr           2.2.0    2020-04-20 [1] CRAN (R 3.6.3)                      
##  xfun            0.13     2020-04-13 [1] CRAN (R 3.6.3)                      
##  XML             3.99-0.3 2020-01-20 [1] CRAN (R 3.6.3)                      
##  yaml            2.2.1    2020-02-01 [1] CRAN (R 3.6.3)                      
## 
## [1] /home/runner/work/_temp/Library
## [2] /opt/R/3.6.3/lib/R/library&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Installing spatial R packages on Ubuntu</title>
      <link>/post/2020/installing-r-spatial-ubuntu/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/installing-r-spatial-ubuntu/</guid>
      <description>


&lt;p&gt;This post explains how to quickly get key R packages for geographic research installed on &lt;a href=&#34;https://ubuntu.com/&#34;&gt;Ubuntu&lt;/a&gt;, a popular Linux distribution.&lt;/p&gt;
&lt;!-- ![](/home/robin/geocompr/geocompr.github.io/static/img/geocompr-linux.png) --&gt;
&lt;p&gt;A recent thread on the &lt;a href=&#34;https://github.com/r-spatial/discuss/issues/35&#34;&gt;r-spatial GitHub organization&lt;/a&gt; alludes to many considerations when choosing a Linux set-up for work with geographic data, ranging from the choice of Linux distribution (distro) to the use of binary vs or compiled versions (binaries are faster to install). This post touches on some of these things.
Its main purpose, though, is to provide advice on getting Râ€™s key spatial packages up-and-running on a future-proof Linux operating system (Ubuntu).&lt;/p&gt;
&lt;p&gt;Now is a good time to be thinking about your R set-up because changes are in the pipeline and getting set-up (or preparing to get set-up) now could save hours in the future.
These imminent changes include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The next major release of R (&lt;a href=&#34;https://stat.ethz.ch/R-manual/R-devel/doc/html/NEWS.html&#34;&gt;4.0.0&lt;/a&gt;), scheduled for the 24&lt;sup&gt;th&lt;/sup&gt; April (&lt;a href=&#34;https://developer.r-project.org/&#34;&gt;2020-04-24&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;The next major release of Ubuntu (&lt;a href=&#34;https://www.omgubuntu.co.uk/2019/10/ubuntu-20-04-release-features&#34;&gt;20.04&lt;/a&gt;), a Long Term Support (&lt;a href=&#34;https://wiki.ubuntu.com/LTS&#34;&gt;LTS&lt;/a&gt;) version that will be used by millions of servers and research computers worldwide for years to come. Coincidentally, Ubuntu 20.04 will be released a day earlier than R 4.0.0, on 23&lt;sup&gt;rd&lt;/sup&gt; April (&lt;a href=&#34;https://itsfoss.com/ubuntu-20-04-release-features/&#34;&gt;2020-04-23&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Ongoing changes to the OSGeo stack on which key geographic R packages depend, as documented in &lt;a href=&#34;https://github.com/r-spatial/&#34;&gt;r-spatial&lt;/a&gt; repos and a recent blog post on how recent versions of PROJ enable more precise &lt;a href=&#34;https://www.r-spatial.org/r/2020/03/17/wkt.html&#34;&gt;coordinate reference system definitions&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To keep-up with these changes, this post will be updated in late April when some of the dust has settled around these changes.
However, the advice presented here should be future-proof.
Upgrading Ubuntu is covered in the next section.&lt;/p&gt;
&lt;p&gt;There many ways of getting Ubuntu set-up for spatial R packages.
A benefit of Linux operating systems is that they offer choice and prevent â€˜lock-inâ€™.
However, the guidance in the next section should reduce set-up time and improve maintainability (with updates managed by Ubuntu) compared with other ways of doing things, especially for beginners.
If youâ€™re planning to switch to Linux as the basis of your geographic work, this advice may be particularly useful.
(The post was written in response to colleagues asking me how to set-up R on their new Ubuntu computers.
If you would like a a computer running Ubuntu, check out &lt;a href=&#34;https://itsfoss.com/get-linux-laptops/&#34;&gt;companies that support open source operating systems&lt;/a&gt; and &lt;a href=&#34;https://ubuntu.com/tutorials/tutorial-install-ubuntu-desktop#1-overview&#34;&gt;guides on installing Ubuntu on an existing machine&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;By â€˜key packagesâ€™ I mean the following, which enable the majority of day-to-day geographic data processing and visualization tasks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/r-spatial/sf#installing&#34;&gt;&lt;strong&gt;sf&lt;/strong&gt;&lt;/a&gt; for reading, writing and working with a range geographic vector file formats and geometry types&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rspatial/raster/&#34;&gt;&lt;strong&gt;raster&lt;/strong&gt;&lt;/a&gt;, a mature package for working with geographic raster data (see the &lt;a href=&#34;https://github.com/rspatial/terra/&#34;&gt;&lt;strong&gt;terra&lt;/strong&gt;&lt;/a&gt; for an in-development replacement for &lt;strong&gt;raster&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mtennekes/tmap&#34;&gt;&lt;strong&gt;tmap&lt;/strong&gt;&lt;/a&gt;, a flexible package for making static and interactive maps&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The focus is on Ubuntu because thatâ€™s what Iâ€™ve got most experience with and it is well supported by the community.
Links for installing geographic R packages on other distros are provided in section 3.&lt;/p&gt;
&lt;div id=&#34;installing-spatial-r-packages-on-ubuntu&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;1. Installing spatial R packages on Ubuntu&lt;/h1&gt;
&lt;!-- Of course, it depends on what Linux distribution you&#39;re running, and we&#39;ll cover installation on some of the most popular [distros](https://distrowatch.com/). --&gt;
&lt;!-- ## Ubuntu --&gt;
&lt;p&gt;Râ€™s spatial packages can be installed from source on the latest version of this popular operating system, once the appropriate repository has been set-up, meaning faster install times (only a few minutes including the installation of upstream dependencies).
The following bash commands should install key geographic R packages on Ubuntu 19.10:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# add a repository that ships the latest version of R:
sudo add-apt-repository ppa:marutter/rrutter3.5
# update the repositories so the software can be found:
sudo apt update
# install system dependencies:
sudo apt install libudunits2-dev libgdal-dev libgeos-dev libproj-dev libfontconfig1-dev
# binary versions of key R packages:
sudo apt install r-base-dev r-cran-sf r-cran-raster r-cran-rjava&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To test your installation of R has worked, try running R in an IDE such as RStudio or in the terminal by entering &lt;code&gt;R&lt;/code&gt;.
You should be able to run the following commands without problem:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)
#&amp;gt; Linking to GEOS 3.7.2, GDAL 2.4.2, PROJ 5.2.0
install.packages(&amp;quot;tmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are using an older version of Ubuntu and donâ€™t want to upgrade to 19.10, which will upgrade to (20.04) by the end of April 2020, see instructions at &lt;a href=&#34;https://github.com/r-spatial/sf#installing&#34;&gt;github.com/r-spatial/sf&lt;/a&gt; and detailed instructions on the blog &lt;a href=&#34;https://rtask.thinkr.fr/blog/installation-of-r-3-5-on-ubuntu-18-04-lts-and-tips-for-spatial-packages/&#34;&gt;rtask.thinkr.fr&lt;/a&gt;, which contains this additional shell command:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# for Ubuntu 18.04
sudo add-apt-repository ppa:marutter/c2d4u3.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That adds a repository that ships hundreds of binary versions of R packages, meaning faster install times for packages (see the &lt;a href=&#34;https://r-pkgs.org/package-structure-state.html#binary-package&#34;&gt;Binary package section of the open source book R Packages&lt;/a&gt; for more on binary packages).
An updated repository, called c2d4u4.0 or similar, will be available for Ubuntu 20.04 in late April.&lt;/p&gt;
&lt;!-- The c2d4u3.5 repository only supports LTS Ubuntu versions, meaning it is unavailable for Ubuntu 19.10, but will be available for Ubuntu 20.04, allowing hundreds of packages to be installed quickly from the system terminal. --&gt;
&lt;!-- The following command, for example, will install **tmap** on LTS versions of Ubuntu that have the `c2d4u3.5` repository enabled much faster than the alternative `install.packages()` approach. --&gt;
&lt;p&gt;If you have issues with the instructions in this post here, you can find a wealth of answers on site such as &lt;a href=&#34;https://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt;, the &lt;a href=&#34;https://github.com/r-spatial/sf/issues&#34;&gt;sf issue tracker&lt;/a&gt;, &lt;a href=&#34;https://stat.ethz.ch/pipermail/r-sig-geo/&#34;&gt;r-sig-geo&lt;/a&gt; and &lt;a href=&#34;https://stat.ethz.ch/pipermail/r-sig-debian/2020-March/thread.html&#34;&gt;Debian&lt;/a&gt; special interest group (SIG) email lists (the latter of which provided input into this blog post, thanks to Dirk Eddelbuettel and Michael Rutter).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;updating-r-packages-and-upstream-dependencies&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;2. Updating R packages and upstream dependencies&lt;/h1&gt;
&lt;p&gt;Linux operating systems allow you to customize your set-up in myriad ways.
This can be enlightening but it can also be wasteful, so itâ€™s worth considering the stability/cutting-edge continuum before diving into a particular set-up and potentially wasting time (if the previous section hasnâ€™t already made-up your mind).&lt;/p&gt;
&lt;!-- For me, a good set-up, that means the latest version of Ubuntu plus CRAN versions of most R packages. --&gt;
&lt;!-- For most people I recommend installing the release version as follows: --&gt;
&lt;p&gt;A reliable way to keep close (but not too close) to the cutting edge on the R side on any operating system is simply to keep your packages up-to-date.
Running the following command (or using the Tools menu in RStudio) every week or so will ensure you have up-to-date package versions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;update.packages()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Keeping system dependencies, software that R relies on but that is not maintained by R developers, is also important but can be tricky, especially for large and complex libraries like GDAL.
On Ubuntu dependencies are managed by apt, and the following commands will update the â€˜OSGeo stackâ€™, composed of PROJ, GEOS and GDAL, if changes are detected in the default repositories (from 18.10 onwards):&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;sudo apt update # see if things have changed
sudo apt upgrade # install changes&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following commands will upgrade to a newer version of Ubuntu (it may be worth waiting until the &lt;a href=&#34;https://ubuntu.com/blog/first-point-release-of-18-04-lts-available-today&#34;&gt;point release&lt;/a&gt; of Ubuntu 20.04 â€” 20.04.1 â€” is released in summer before upgrading if youâ€™re currently running Ubuntu 18.04 if high stability and low set-up times are priorities; also see instructions &lt;a href=&#34;https://ubuntu.com/tutorials/tutorial-upgrading-ubuntu-desktop#3-check-for-updates&#34;&gt;here&lt;/a&gt;):&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;apt dist-upgrade&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get more up-to-date upstream geographic libraries than provided in the default Ubuntu repositories, you can add the &lt;code&gt;ubuntugis&lt;/code&gt; repository as follows.
This is a pre-requisite on Ubuntu 18.04 and earlier but also works with later versions (warning, adding this repository could cause complications if you already have software such as QGIS that uses a particular version of GDAL installed):&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable
sudo apt update
sudo apt upgrade&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That will give you more up-to-date versions of GDAL, GEOS and PROJ which may offer some performance improvements.
Note: if you do update dependencies such as GDAL you will need to re-install the relevant packages, e.g.Â with &lt;code&gt;install.packages(&#34;sf&#34;)&lt;/code&gt;.
You can revert that change with the following &lt;a href=&#34;https://askubuntu.com/questions/904010/how-to-remove-a-ppa-from-cli&#34;&gt;little-known command&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;sudo add-apt-repository --remove ppa:ubuntugis/ubuntugis-unstable&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you also want the development versions of key R packages, e.g.Â to test new features and support development efforts, you can install them from GitHub, e.g.Â as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;remotes::install_github(&amp;quot;r-spatial/sf&amp;quot;)
remotes::install_github(&amp;quot;rspatial/raster&amp;quot;)
remotes::install_github(&amp;quot;mtennekes/tmaptools&amp;quot;) # required for dev version of tmap
remotes::install_github(&amp;quot;mtennekes/tmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;installing-geographic-r-packages-on-other-linux-operating-systems&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;3. Installing geographic R packages on other Linux operating systems&lt;/h1&gt;
&lt;p&gt;If you are in the fortunate position of switching to Linux and being able to choose the distribution that best fits your needs, itâ€™s worth thinking about which distribution will be both user-friendly (more on that soon), performant and future-proof.
Ubuntu is a solid choice, with a large user community and repositories such as â€˜ubuntugisâ€™ providing more up-to-date versions of upstream geographic libraries such as GDAL.&lt;/p&gt;
&lt;p&gt;QGIS is also well-supported on Ubuntu.&lt;/p&gt;
&lt;p&gt;However, you can install R and key geographic packages on other operating systems, although it may take longer.
Useful links on installing R and geographic libraries are provided below for reference:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Installing R on &lt;strong&gt;Debian&lt;/strong&gt; is covered on the &lt;a href=&#34;https://cran.r-project.org/bin/linux/debian/&#34;&gt;CRAN website&lt;/a&gt;. Upstream dependencies such as GDAL can be installed on recent versions of Debian, such as &lt;a href=&#34;https://www.debian.org/releases/&#34;&gt;buster&lt;/a&gt;, with commands such as &lt;code&gt;apt install libgdal-dev&lt;/code&gt; as per instructions on the &lt;a href=&#34;https://github.com/rocker-org/geospatial/blob/eaf5e92f90737ce9771753cab48f3a2f1d779216/Dockerfile&#34;&gt;rocker/geospatial&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Installing R on &lt;strong&gt;Fedora/Red Hat&lt;/strong&gt; is straightforward, as outlined on &lt;a href=&#34;https://cran.r-project.org/bin/linux/redhat/README&#34;&gt;CRAN&lt;/a&gt;. GDAL and other spatial libraries can be installed from Fedoraâ€™s &lt;code&gt;dnf&lt;/code&gt; package manager, e.g.Â as documented &lt;a href=&#34;https://github.com/r-spatial/sf#fedora&#34;&gt;here&lt;/a&gt; for &lt;strong&gt;sf&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Arch Linux&lt;/strong&gt; has a growing R community. Information on installing and setting-up R can be found on the &lt;a href=&#34;https://wiki.archlinux.org/index.php/R&#34;&gt;ArchLinux wiki&lt;/a&gt;. Installing upstream dependencies such as &lt;a href=&#34;https://www.archlinux.org/packages/community/x86_64/gdal/&#34;&gt;GDAL on Arch&lt;/a&gt; is also relatively straightforward. There is also a detailed guide for installing R plus geographic packages by &lt;a href=&#34;https://pat-s.me/post/arch-install-guide-for-r/&#34;&gt;Patrick Schratz&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;geographic-r-packages-on-docker&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;4. Geographic R packages on Docker&lt;/h1&gt;
&lt;!-- As with cars, ease of use is important for the popularity of computer technology. --&gt;
&lt;!-- ^[ --&gt;
&lt;!-- The history of cars can provide insight into the importance of ease of use of technologies today. --&gt;
&lt;!-- Cars, have arguably transformed our settlements and lifestyles more than any other technology, were initially hard to use. --&gt;
&lt;!-- Before they became a consumer product in the 1950s (by the end of which 1/6^th^ of jobs in the USA were in the [car industry](https://en.wikipedia.org/wiki/1950s_American_automobile_culture)) relied on a [hand cranks](https://www.youtube.com/watch?v=iFd8uo7ogpM) to start them until the proliferation of electric starter motors following U.S. Patent [1,150,523](https://patents.google.com/patent/US1150523), which was subsequently used by Cadillac in [1912](https://www.hemmings.com/blog/2012/02/27/the-accident-that-started-it-all/) and onwards. --&gt;
&lt;!-- Like cars, people tend to go for computer technologies that are easy to use, that are &#39;plug and play&#39;, so it&#39;s important for the future of open-source software that the solutions I recommend are easy to set-up and use. --&gt;
&lt;!-- ] --&gt;
&lt;p&gt;The Ubuntu installation instructions outlined above provide such an easy and future-proof set-up.
But if you want an even easier way to get the power of key geographic packages running on Linux, and have plenty of RAM and HD space, running R on the â€˜&lt;a href=&#34;https://docs.docker.com/install/&#34;&gt;Docker Engine&lt;/a&gt;â€™ may be an attractive option.&lt;/p&gt;
&lt;p&gt;Advantages of using Docker include &lt;strong&gt;reproducibility&lt;/strong&gt; (code will always run the same on any given image, and images can be saved), &lt;strong&gt;portability&lt;/strong&gt; (Docker can run on Linux, Windows and Mac) and &lt;strong&gt;scalability&lt;/strong&gt; (Docker provides a platform for scaling-up computations across multiple nodes).&lt;/p&gt;
&lt;p&gt;For an introduction to using R/RStudio in Docker, see the &lt;a href=&#34;https://www.rocker-project.org/&#34;&gt;Rocker project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Using that approach, I recommend the following Docker images for using R as a basis for geographic research:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/rocker/geospatial&#34;&gt;&lt;code&gt;rocker/geospatial&lt;/code&gt;&lt;/a&gt; which contains key geographic packages, including those listed above&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/robinlovelace/geocompr/&#34;&gt;&lt;code&gt;robinlovelace/geocompr&lt;/code&gt;&lt;/a&gt; which contains all the packages needed to reproduce the contents of the &lt;a href=&#34;https://geocompr.robinlovelace.net/&#34;&gt;book&lt;/a&gt;, and which you can run with the following command in a shell in which Docker is installed:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;docker run -e PASSWORD=yourpassword --rm -p 8787:8787 robinlovelace/geocompr&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To test-out the Ubuntu 19.10 set-up recommended above I created a &lt;a href=&#34;https://github.com/Robinlovelace/geocompr/blob/master/docker/ubuntu-eoan/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt; and associated image on Dockerhub that you can test-out as follows:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;docker run -it robinlovelace/geocompr:ubuntu-eoan
R
library(sf)
#&amp;gt; Linking to GEOS 3.7.2, GDAL 2.4.2, PROJ 5.2.0
library(raster)
library(tmap) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The previous commands should take you to a terminal inside the docker container where you try out the Linux command line and R.
If you want to use more cutting-edge versions of the geographic libraries, you can use the &lt;code&gt;ubuntu-bionic&lt;/code&gt; image (note the more recent version numbers, with PROJ 7.0.0 for example):&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;sudo docker run -it robinlovelace/geocompr:ubuntu-bionic
R
library(sf)
#&amp;gt; Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 7.0.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These images do not currently contain all the dependencies needed to reproduce the code in &lt;em&gt;Geocomputation with R&lt;/em&gt;.
&lt;!-- , if you&#39;re looking for a production-ready Docker image that has both RStudio Server and a wide range of geographic packages pre-installed, building from the `rocker/geospatial` image, this could be a good place to start: --&gt;&lt;/p&gt;
&lt;p&gt;However, as documented in &lt;a href=&#34;https://github.com/Robinlovelace/geocompr/issues/476&#34;&gt;issue 476&lt;/a&gt; in the &lt;code&gt;geocompr&lt;/code&gt; GitHub repo, there is a plan to provide Docker images with this full â€˜R-spatialâ€™ stack installed, building on strong foundations such as &lt;code&gt;rocker/geospatial&lt;/code&gt; and the &lt;code&gt;ubuntugis&lt;/code&gt; repositories, to support different versions of GDAL and other dependencies.
We welcome any comments or tech support to help make this happen.
Suggested changes to this post are also welcome, see the source code &lt;a href=&#34;https://github.com/geocompr/geocompr.github.io/blob/source/content/post/2020/installing-r-spatial-packages-linux.Rmd&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fin&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;5. Fin&lt;/h1&gt;
&lt;p&gt;R is an open-source language heavily inspired by Unix/Linux so it should come as no surprise that it runs well on a variety of Linux distributions, Ubuntu (covered in this post) in particular.
The guidance in this post should get geographic R packages set-up quickly in a future-proof way.
A sensible next step is to sharpen you system administration (sysadmin) and shell coding skills, e.g.Â with reference to &lt;a href=&#34;https://help.ubuntu.com/community/SystemAdministration&#34;&gt;Ubuntu wiki pages&lt;/a&gt; and &lt;a href=&#34;https://www.datascienceatthecommandline.com/chapter-2-getting-started.html#essential-gnulinux-concepts&#34;&gt;Chapter 2&lt;/a&gt; of the open source book &lt;a href=&#34;https://www.datascienceatthecommandline.com&#34;&gt;Data Science at the Command Line&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This will take time but, building on &lt;a href=&#34;https://www.osgeo.org/&#34;&gt;OSGeo&lt;/a&gt; libraries, a well set-up Linux machine is an ideal platform to install, run and develop key geographic R packages in a performant, stable and future-proof way.
&lt;!-- I hope that this tutorial provides some useful pointers and encourages more people to switch from proprietary software to open source solutions as the basis of their geographic and computational work. --&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.osgeo.org/wp-content/themes/roots/assets/img/logo-osgeo.svg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Be the &lt;a href=&#34;https://wiki.osgeo.org/wiki/FOSS4G&#34;&gt;FOSS4G&lt;/a&gt; change you want to see in the world!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Inset maps with ggplot2</title>
      <link>/post/2019/ggplot2-inset-maps/</link>
      <pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/ggplot2-inset-maps/</guid>
      <description>


&lt;p&gt;Inset maps enable multiple places to be shown in the same geographic data visualisation, as described in the &lt;a href=&#34;https://geocompr.robinlovelace.net/adv-map.html#inset-maps&#34;&gt;Inset maps section (8.2.7)&lt;/a&gt; of our open source book Geocomputation with R.
The topic of inset maps has gained attention and recently &lt;a href=&#34;https://twitter.com/espinielli/&#34;&gt;Enrico Spinielli&lt;/a&gt; asked inset maps could be created for data in unusual coordinate systems:&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Speaking of insets, do you know of any ggplot2 examples with an inset for showing where the (bbox of the) map is in an orthographic/satellite proj? It is usually done to provide geographic context... NYT/WP have fantastic maps like that&lt;/p&gt;&amp;mdash; espinielli (@espinielli) &lt;a href=&#34;https://twitter.com/espinielli/status/1191452410394361863?ref_src=twsrc%5Etfw&#34;&gt;November 4, 2019&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;Râ€™s flexibility allows inset maps to be created in various ways, using different approaches and packages.
However, the main idea stays the same: we need to create at least two maps: a larger one, called the main map, that shows the central story and a smaller one, called the inset map, that puts the main map in context.&lt;/p&gt;
&lt;p&gt;This blog post shows how to create inset maps with &lt;strong&gt;ggplot2&lt;/strong&gt; for visualization.
The approach also uses the &lt;strong&gt;sf&lt;/strong&gt; package for spatial data reading and handling, &lt;strong&gt;cowplot&lt;/strong&gt; to arrange inset maps, and &lt;strong&gt;rcartocolor&lt;/strong&gt; for additional color palettes.
To reproduce the results on your own computer, after installing them, these packages can be attached as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)
library(ggplot2)
library(cowplot)
library(rcartocolor)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;basic-inset-map&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic inset map&lt;/h1&gt;
&lt;p&gt;Letâ€™s start by creating a basic inset map.&lt;/p&gt;
&lt;div id=&#34;data-preparation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data preparation&lt;/h2&gt;
&lt;p&gt;The first step is to read and prepare the data we want to visualize.
We use the &lt;code&gt;us_states&lt;/code&gt; data from the &lt;strong&gt;spData&lt;/strong&gt; package as the source of the inset map, and &lt;code&gt;north_carolina&lt;/code&gt; from the &lt;strong&gt;sf&lt;/strong&gt; package as the source of the main map.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(spData)
data(&amp;quot;us_states&amp;quot;, package = &amp;quot;spData&amp;quot;)
north_carolina = read_sf(system.file(&amp;quot;shape/nc.shp&amp;quot;, package = &amp;quot;sf&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both objects should have the same coordinate reference system (&lt;code&gt;crs&lt;/code&gt;).
Here, we use &lt;code&gt;crs = 2163&lt;/code&gt;, which represents the US National Atlas Equal Area projection.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;us_states_2163 = st_transform(us_states, crs = 2163)
north_carolina_2163 = st_transform(north_carolina, crs = 2163)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also need to have the borders of the area we want to highlight (use in the main map).
This can be done by extracting the bounding box of our &lt;code&gt;north_carolina_2163&lt;/code&gt; object.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;north_carolina_2163_bb = st_as_sfc(st_bbox(north_carolina_2163))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;maps-creation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Maps creation&lt;/h2&gt;
&lt;p&gt;The second step is to create both inset and main maps independently.
The inset map should show the context (larger area) and highlight the area of interest.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggm1 = ggplot() + 
  geom_sf(data = us_states_2163, fill = &amp;quot;white&amp;quot;) + 
  geom_sf(data = north_carolina_2163_bb, fill = NA, color = &amp;quot;red&amp;quot;, size = 1.2) +
  theme_void()

ggm1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/ggplot2-inset-maps_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The main mapâ€™s role is to tell the story.
Here we show the number of births between 1974 and 1978 in the North Carolina counties (the &lt;code&gt;BIR74&lt;/code&gt; variable) using the Mint color palette from the &lt;strong&gt;rcartocolor&lt;/strong&gt; palette.
We also customize the legend position and size - this way, the legend is a part of the map, instead of being somewhere outside the map frame.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggm2 = ggplot() + 
  geom_sf(data = north_carolina_2163, aes(fill = BIR74)) +
  scale_fill_carto_c(palette = &amp;quot;Mint&amp;quot;) +
  theme_void() +
  theme(legend.position = c(0.4, 0.05),
        legend.direction = &amp;quot;horizontal&amp;quot;,
        legend.key.width = unit(10, &amp;quot;mm&amp;quot;))

ggm2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/ggplot2-inset-maps_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;maps-joining&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Maps joining&lt;/h2&gt;
&lt;p&gt;The final step is to join two maps.
This can be done using functions from the &lt;strong&gt;cowplot&lt;/strong&gt; package.
We create an empty ggplot layer using &lt;code&gt;ggdraw()&lt;/code&gt;, fill it with out main map (&lt;code&gt;draw_plot(ggm2)&lt;/code&gt;), and add an inset map by specifing its position and size:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg_inset_map1 = ggdraw() +
  draw_plot(ggm2) +
  draw_plot(ggm1, x = 0.05, y = 0.65, width = 0.3, height = 0.3)

gg_inset_map1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/ggplot2-inset-maps_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The final map can be saved using the &lt;code&gt;ggsave()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggsave(filename = &amp;quot;01_gg_inset_map.png&amp;quot;, 
       plot = gg_inset_map1,
       width = 8, 
       height = 4,
       dpi = 150)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;advanced-inset-map&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Advanced inset map&lt;/h1&gt;
&lt;p&gt;Letâ€™s expand the idea of the inset map in &lt;strong&gt;ggplot2&lt;/strong&gt; based on the previous example.&lt;/p&gt;
&lt;div id=&#34;data-preparation-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data preparation&lt;/h2&gt;
&lt;p&gt;This map will use the US states borders (&lt;code&gt;states()&lt;/code&gt;) as the source of the inset map and the Kentucky Senate legislative districts (&lt;code&gt;state_legislative_districts()&lt;/code&gt;) as the main map.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tigris)
options(tigris_use_cache = TRUE)
us_states = states(cb = FALSE, class = &amp;quot;sf&amp;quot;)
ky_districts = state_legislative_districts(&amp;quot;KY&amp;quot;, house = &amp;quot;upper&amp;quot;,
                                           cb = FALSE, class = &amp;quot;sf&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;states()&lt;/code&gt; function, in addition to the 50 states, also returns the District of Columbia, Puerto Rico, American Samoa, the Commonwealth of the Northern Mariana Islands, Guam, and the US Virgin Islands.
For our purpose, we are interested in the continental 48 states and the District of Columbia only; therefore, we remove the rest of the divisions using &lt;code&gt;subset()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;us_states = subset(us_states, 
                   !NAME %in% c(
                     &amp;quot;United States Virgin Islands&amp;quot;,
                     &amp;quot;Commonwealth of the Northern Mariana Islands&amp;quot;,
                     &amp;quot;Guam&amp;quot;,
                     &amp;quot;American Samoa&amp;quot;,
                     &amp;quot;Puerto Rico&amp;quot;,
                     &amp;quot;Alaska&amp;quot;,
                     &amp;quot;Hawaii&amp;quot;
                   ))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same as in the example above, we transform both objects to have the same projection.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ky_districts_2163 = st_transform(ky_districts, crs = 2163)
us_states_2163 = st_transform(us_states, crs = 2163)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also extract the bounding box of the main object here.
However, instead of using it directly, we add a buffer of 10,000 meters around it.
This output will be handy in both inset and main maps.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ky_districts_2163_bb = st_as_sfc(st_bbox(ky_districts_2163))
ky_districts_2163_bb = st_buffer(ky_districts_2163_bb, dist = 10000)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ky_districts_2163&lt;/code&gt; object does not have any interesting variables to visualize, so we create some random values here.
However, we could also join the districtsâ€™ data with another dataset in this step.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ky_districts_2163$values = runif(nrow(ky_districts_2163))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;map-creation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Map creation&lt;/h2&gt;
&lt;p&gt;The inset map should be as clear and simple as possible.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggm3 = ggplot() + 
  geom_sf(data = us_states_2163, fill = &amp;quot;white&amp;quot;, size = 0.2) + 
  geom_sf(data = ky_districts_2163_bb, fill = NA, color = &amp;quot;blue&amp;quot;, size = 1.2) +
  theme_void()

ggm3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/ggplot2-inset-maps_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;On the other hand, the main map looks better when we provide some additional context to our data.
One of the ways to achieve it is to add the borders of the neighboring states.&lt;/p&gt;
&lt;p&gt;Importantly, we also need to limit the extent of our main map to the range of the frame in the inset map.
This can be done with the &lt;code&gt;coord_sf()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggm4 = ggplot() + 
  geom_sf(data = us_states_2163, fill = &amp;quot;#F5F5DC&amp;quot;) +
  geom_sf(data = ky_districts_2163, aes(fill = values)) +
  scale_fill_carto_c(palette = &amp;quot;Sunset&amp;quot;) +
  theme_void() +
  theme(legend.position = c(0.5, 0.07),
        legend.direction = &amp;quot;horizontal&amp;quot;,
        legend.key.width = unit(10, &amp;quot;mm&amp;quot;),
        plot.background = element_rect(fill = &amp;quot;#BFD5E3&amp;quot;)) +
  coord_sf(xlim = st_bbox(ky_districts_2163_bb)[c(1, 3)],
           ylim = st_bbox(ky_districts_2163_bb)[c(2, 4)])

ggm4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/ggplot2-inset-maps_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Finally, we draw two maps together, trying to find the best location and size for the inset map.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg_inset_map2 = ggdraw() +
  draw_plot(ggm4) +
  draw_plot(ggm3, x = 0.02, y = 0.65, width = 0.35, height = 0.35)

gg_inset_map2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/ggplot2-inset-maps_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The final map can be saved using the &lt;code&gt;ggsave()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggsave(filename = &amp;quot;02_gg_inset_map.png&amp;quot;, 
       plot = gg_inset_map2,
       width = 7.05, 
       height = 4,
       dpi = 150)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;summary&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;The above examples can be adjusted to any spatial data and location.
It is also possible to put more context on the map, including adding main citiesâ€™ names, neighboring statesâ€™ names, and annotations (using &lt;code&gt;geom_text()&lt;/code&gt;, &lt;code&gt;geom_label()&lt;/code&gt;).
The main map can also be enhanced with the north arrow and scale bar using the &lt;a href=&#34;https://github.com/oswaldosantos/ggsn&#34;&gt;&lt;strong&gt;ggsn&lt;/strong&gt;&lt;/a&gt; package.&lt;/p&gt;
&lt;p&gt;As always with R, there are many possible options to create inset maps.
You can find two examples of inset maps created using the &lt;strong&gt;tmap&lt;/strong&gt; package in &lt;a href=&#34;https://geocompr.robinlovelace.net/adv-map.html#inset-maps&#34;&gt;the Geocomputation with R book&lt;/a&gt;.
The second example is a classic map of the United States, which consists of the contiguous United States, Hawaii, and Alaska.
However, Hawaii and Alaska are displayed at different geographic scales than the main map there.
This problem can also be solved in R, which you can see in &lt;a href=&#34;https://nowosad.github.io/post/making-alternative-inset-maps-of-the-usa/&#34;&gt;the Making maps of the USA with R: alternative layout&lt;/a&gt; blogpost and the &lt;a href=&#34;https://github.com/Nowosad/us-map-alternative-layout&#34;&gt;Alternative layout for maps of the United States&lt;/a&gt; repository.&lt;/p&gt;
&lt;p&gt;The presented approaches also apply to other areas.
For example, you can find three ways on how to create an inset map of Spain in the &lt;a href=&#34;https://github.com/Nowosad/spain-map-layout&#34;&gt;Alternative layout for maps of Spain&lt;/a&gt; repository.
Other examples of inset maps with &lt;strong&gt;ggplot2&lt;/strong&gt; can be found in the &lt;a href=&#34;https://ryanpeek.github.io/mapping-in-R-workshop/vig_making_inset_maps.html&#34;&gt;Inset Maps&lt;/a&gt; vignette by &lt;a href=&#34;https://twitter.com/riverpeek&#34;&gt;Ryan Peek&lt;/a&gt; and the blog post &lt;a href=&#34;https://www.r-spatial.org/r/2018/10/25/ggplot2-sf-3.html&#34;&gt;Drawing beautiful maps programmatically with R, sf and ggplot2&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/melimore86&#34;&gt;Mel Moreno&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/MabLabUF&#34;&gt;Mathieu Basille&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The decision which option to use depends on the expected map type preferred R packages, etc.
Try different approaches on your own data and decide what works best for you!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Map coloring: the color scale styles available in the tmap package</title>
      <link>/post/2019/tmap-color-scales/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/tmap-color-scales/</guid>
      <description>


&lt;p&gt;This vignette builds on the &lt;a href=&#34;https://geocompr.robinlovelace.net/adv-map.html&#34;&gt;making maps chapter&lt;/a&gt; of &lt;a href=&#34;https://geocompr.github.io/&#34;&gt;the Geocomputation with R book&lt;/a&gt;.
Its goal is to demonstrate all possible map styles available in the &lt;strong&gt;tmap&lt;/strong&gt; package.&lt;/p&gt;
&lt;div id=&#34;prerequisites&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;The examples below assume the following packages are attached:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(spData) # example datasets
library(tmap)   # map creation
library(sf)     # spatial data reprojection&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;world&lt;/code&gt; object containing a world map data from &lt;a href=&#34;https://www.naturalearthdata.com/&#34;&gt;Natural Earth&lt;/a&gt; and information about countriesâ€™ names, regions, and subregions they belong to, areas, life expectancies, and populations.
This object is in geographical coordinates using the WGS84 datum, however, for mapping purposes, the Mollweide projection is a better alternative (learn more in &lt;a href=&#34;https://geocompr.robinlovelace.net/reproj-geo-data.html#modifying-map-projections&#34;&gt;the modifying map projections section&lt;/a&gt;).
The &lt;code&gt;st_tranform&lt;/code&gt; function from the &lt;strong&gt;sf&lt;/strong&gt; package allows for quick reprojection to the selected coordinate reference system (e.g., &lt;code&gt;&#34;+proj=moll&#34;&lt;/code&gt; represents the Mollweide projection).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world_moll = st_transform(world, crs = &amp;quot;+proj=moll&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;one-color&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;One color&lt;/h1&gt;
&lt;p&gt;Letâ€™s start with the basics.
To create a simple world map, we need to specify the data object (&lt;code&gt;world_moll&lt;/code&gt;) inside the &lt;code&gt;tm_shape()&lt;/code&gt; function, and the way we want to visualize it.
The &lt;strong&gt;tmap&lt;/strong&gt; package offers several visualisation possibilities for polygons, including &lt;code&gt;tm_borders()&lt;/code&gt;, &lt;code&gt;tm_fill()&lt;/code&gt;, and &lt;code&gt;tm_polygons()&lt;/code&gt;.
The last one draws the filled polygons with borders, where the fill color can be specified with the &lt;code&gt;col&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lightblue&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The output is a map of world countries, where each country is filled with a light blue color.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;coloring-of-adjacent-polygons&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Coloring of adjacent polygons&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;col&lt;/code&gt; argument is very flexible, and its action depends on the value provided.
In the previous example, we provided a single color value resulting in a map with one color.
To create a map, where adjacent polygons do not get the same color, we need to provide a keyword &lt;code&gt;&#34;MAP_COLORS&#34;&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;MAP_COLORS&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The default color can be changed using the &lt;code&gt;palette&lt;/code&gt; argument - run the &lt;code&gt;tmaptools::palette_explorer()&lt;/code&gt; function to see possible palettesâ€™ names.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;MAP_COLORS&amp;quot;,
              palette = &amp;quot;Pastel1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;!-- Additionally, the number of classes can be set using the `n` argument. --&gt;
&lt;p&gt;Additionally, in this case, it is possible to use the &lt;code&gt;minimize&lt;/code&gt; argument, which triggers the internal algorithm to search for a minimal number of colors for visualization.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;MAP_COLORS&amp;quot;,
              minimize = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The new map uses five colors&lt;!-- except for Angola (blue color)--&gt;.
On a side note, in theory, no more than four colors are required to color the polygons of the map so that no two adjacent polygons have the same color (learn more about the four color map theorem on &lt;a href=&#34;https://en.wikipedia.org/wiki/Four_color_theorem&#34;&gt;Wikipedia&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;categorical-maps&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Categorical maps&lt;/h1&gt;
&lt;p&gt;The third use of the &lt;code&gt;col&lt;/code&gt; argument is by providing the variable (column) name.
In this case, the map will represent the given variable.
By default, &lt;strong&gt;tmap&lt;/strong&gt; behaves differently depending on the input variable type.
For example, it will create a categorical map when the provided variable contains characters or factors.
The &lt;code&gt;tm_polygons(col = &#34;subregion&#34;, style = &#34;cat&#34;)&lt;/code&gt; code will be run automatically in this case.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;subregion&amp;quot;)+
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;discrete-maps&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Discrete maps&lt;/h1&gt;
&lt;p&gt;Discrete maps represents continuous numerical variables using discrete class intervals.
There are several ways to convert continuous variables to discrete ones implemented in &lt;strong&gt;tmap&lt;/strong&gt;.&lt;/p&gt;
&lt;div id=&#34;pretty&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Pretty&lt;/h2&gt;
&lt;p&gt;When the variable provided as the &lt;code&gt;col&lt;/code&gt; argument is numeric, &lt;strong&gt;tmap&lt;/strong&gt; will use the &lt;code&gt;&#34;pretty&#34;&lt;/code&gt; style as a default.
In other words, it runs &lt;code&gt;tm_polygons(col = &#34;lifeExp&#34;, style = &#34;pretty&#34;)&lt;/code&gt; invisibly to the user.
This style rounds breaks into whole numbers where possible and spaces them evenly.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;,
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;A histogram is added using &lt;code&gt;legend.hist = TRUE&lt;/code&gt; in this and several next examples to show how the selected map style relates to the distribution of values.&lt;/p&gt;
&lt;p&gt;It is possible to indicate a preferred number of classes using the &lt;code&gt;n&lt;/code&gt; argument.
Importantly, not every &lt;code&gt;n&lt;/code&gt; is possible depending on the range of the values in the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;,
              legend.hist = TRUE,
              n = 4) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fixed&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Fixed&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;jenks&#34;&lt;/code&gt; style allows for a manual selection of the breaks in conjunction with the &lt;code&gt;breaks&lt;/code&gt; argument.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;, 
              style = &amp;quot;fixed&amp;quot;,
              breaks = c(45, 60, 75, 90),
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Additionally, the default labels can be overwritten using the &lt;code&gt;labels&lt;/code&gt; argument.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;, 
              style = &amp;quot;fixed&amp;quot;,
              breaks = c(45, 60, 75, 90),
              labels = c(&amp;quot;low&amp;quot;, &amp;quot;medium&amp;quot;, &amp;quot;high&amp;quot;),
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;breaks-based-on-the-standard-deviation-value&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Breaks based on the standard deviation value&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;sd&#34;&lt;/code&gt; style calculates a standard deviation of a given variable, and next use this value as the break width.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;, 
              style = &amp;quot;sd&amp;quot;,
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fisher-algorithm&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Fisher algorithm&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;fisher&#34;&lt;/code&gt; style creates groups with maximalized homogeneity.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;,
              style = &amp;quot;fisher&amp;quot;,
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;jenks-natural-breaks&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Jenks natural breaks&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;jenks&#34;&lt;/code&gt; style identifies groups of similar values in the data and maximizes the differences between categories.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;,
              style = &amp;quot;jenks&amp;quot;,
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;hierarchical-clustering&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Hierarchical clustering&lt;/h2&gt;
&lt;p&gt;In the &lt;code&gt;&#34;hclust&#34;&lt;/code&gt; style, breaks are created using hierarchical clustering.&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;,
              style = &amp;quot;hclust&amp;quot;,
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bagged-clustering&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Bagged clustering&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;bclust&#34;&lt;/code&gt; style uses the &lt;code&gt;bclust&lt;/code&gt; function to generate the breaks using bagged clustering.&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;,
              style = &amp;quot;bclust&amp;quot;,
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## Committee Member: 1(1) 2(1) 3(1) 4(1) 5(1) 6(1) 7(1) 8(1) 9(1) 10(1)
## Computing Hierarchical Clustering&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;k-means-clustering&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;k-means clustering&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;kmeans&#34;&lt;/code&gt; style uses the &lt;code&gt;kmeans&lt;/code&gt; function to generate the breaks.&lt;a href=&#34;#fn5&#34; class=&#34;footnote-ref&#34; id=&#34;fnref5&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;, 
              style = &amp;quot;kmeans&amp;quot;,
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;quantile-breaks&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Quantile breaks&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;quantile&#34;&lt;/code&gt; style creates breaks with an equal number of features (polygons).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;, 
              style = &amp;quot;quantile&amp;quot;,
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;equal-breaks&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Equal breaks&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;equal&#34;&lt;/code&gt; style divides input values into bins of equal range and is appropriate for variables with a uniform distribution.
It is not recommended for variables with a skewed distribution as the resulting map may end-up having little color diversity.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;, 
              style = &amp;quot;equal&amp;quot;,
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Learn more about the implementation of discrete scales in &lt;a href=&#34;https://r-spatial.github.io/classInt/index.html&#34;&gt;the &lt;strong&gt;classInt&lt;/strong&gt; packageâ€™s documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;continuous-maps&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Continuous maps&lt;/h1&gt;
&lt;p&gt;The &lt;strong&gt;tmap&lt;/strong&gt; package also allows for creating continuous maps.&lt;/p&gt;
&lt;div id=&#34;continuous&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Continuous&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;cont&#34;&lt;/code&gt; style presents a large number of colors over the continuous color field.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;,
              style = &amp;quot;cont&amp;quot;) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;order&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Order&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;&#34;order&#34;&lt;/code&gt; style also presents a large number of colors over the continuous color field.
However, this style is suited to visualize skewed distributions; notice that the values on the legend do not change linearly.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;lifeExp&amp;quot;,
              style = &amp;quot;order&amp;quot;) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;logarithmic-scales&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Logarithmic scales&lt;/h1&gt;
&lt;p&gt;The default numeric style, &lt;code&gt;pretty&lt;/code&gt;, is easy to understand, but it is not proper for maps of variables with skewed distributions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;pop&amp;quot;) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-22-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Another possible style, &lt;code&gt;order&lt;/code&gt; works better in this case; however, it is not easy to interpret.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;pop&amp;quot;, 
              style = &amp;quot;order&amp;quot;) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-23-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;A better alternative, in this case, is to use a common logarithm (the logarithm to base 10) scale.
The &lt;strong&gt;tmap&lt;/strong&gt; package gives two possibilities in this case - &lt;code&gt;&#34;log10_pretty&#34;&lt;/code&gt; and &lt;code&gt;&#34;log10&#34;&lt;/code&gt;.
The &lt;code&gt;&#34;log10_pretty&#34;&lt;/code&gt; style is a common logarithmic version of the regular &lt;code&gt;pretty&lt;/code&gt; style.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;pop&amp;quot;, 
              style = &amp;quot;log10_pretty&amp;quot;) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-24-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;On the other hand, the &lt;code&gt;&#34;log10&#34;&lt;/code&gt; style is a version of a continuous scale.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world_moll) +
  tm_polygons(col = &amp;quot;pop&amp;quot;, 
              style = &amp;quot;log10&amp;quot;) +
  tm_layout(legend.outside = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-styles_files/figure-html/unnamed-chunk-25-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;Selecting a color scale style is not an easy task.
It depends on the type of input variable and its distribution, but also the intended audience.
Therefore, it is worth to spend some time and think about your readers (e.g., would they be able to understand the logarithmic scale or should you use the manual breaks instead?) and your data (e.g., how many breaks should there be to show different subgroups?).
Now you know different color scale styles implemented in &lt;strong&gt;tmap&lt;/strong&gt;, so letâ€™s try using them for your own projects!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://www.tandfonline.com/doi/abs/10.1080/01621459.1958.10501479&#34; class=&#34;uri&#34;&gt;https://www.tandfonline.com/doi/abs/10.1080/01621459.1958.10501479&lt;/a&gt;&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;â†©ï¸Ž&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization&#34; class=&#34;uri&#34;&gt;https://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization&lt;/a&gt;&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;â†©ï¸Ž&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;See the &lt;code&gt;?hclust&lt;/code&gt; documentation for more details.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;â†©ï¸Ž&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;See the &lt;code&gt;?bclust&lt;/code&gt; documentation for more details.&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34;&gt;â†©ï¸Ž&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn5&#34;&gt;&lt;p&gt;See the &lt;code&gt;?kmeans&lt;/code&gt; documentation for more details.&lt;a href=&#34;#fnref5&#34; class=&#34;footnote-back&#34;&gt;â†©ï¸Ž&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Hillshade maps</title>
      <link>/post/2020/hillshade-maps/</link>
      <pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/hillshade-maps/</guid>
      <description>


&lt;p&gt;This vignette builds on the &lt;a href=&#34;https://geocompr.robinlovelace.net/adv-map.html&#34;&gt;making maps chapter&lt;/a&gt; of &lt;a href=&#34;https://geocompr.github.io/&#34;&gt;the Geocomputation with R book&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;prerequisites&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;The example below assume the following packages are attached:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(raster) # data download
library(tmap)   # map creation&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;hillshade-map&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Hillshade map&lt;/h1&gt;
&lt;p&gt;Hillshade maps show the topographical shape of hills and mountains using levels of gray on a map.
The role of this kind of maps is to display relative slopes, but not absolute height.&lt;/p&gt;
&lt;div id=&#34;calculate-terrain-characteristics&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Calculate terrain characteristics&lt;/h2&gt;
&lt;p&gt;Elevation data is needed to create a hillshade map.
The &lt;strong&gt;raster&lt;/strong&gt; package provides an easy access to the SRTM 90 m resolution elevation data with the &lt;code&gt;getData()&lt;/code&gt; function.
For example, it is possible to download the elevation data for the whole country of Slovenia using the code below:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;alt = getData(&amp;quot;alt&amp;quot;, country = &amp;quot;SVN&amp;quot;, path = tempdir())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hillshade maps are created based on certain terrain characteristics - slope and aspect.
Slope represents the steepness at each cell of a raster surface.
The lower the slope value - the flatter the terrain.
Aspect is the direction of the maximum slope of the focal cell.
Slope and aspect can be calculated with the &lt;code&gt;terrain&lt;/code&gt; function and the &lt;code&gt;opt&lt;/code&gt; argument set to &lt;code&gt;&#34;slope&#34;&lt;/code&gt; or &lt;code&gt;&#34;aspect&#34;&lt;/code&gt;.
Both values are returned in radians by default.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;slope = terrain(alt, opt = &amp;quot;slope&amp;quot;)
aspect = terrain(alt, opt = &amp;quot;aspect&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;!-- add plots of slope and as pect --&gt;
&lt;!-- explain what&#39;s that  --&gt;
&lt;p&gt;Computing of a hillshade can be done using the &lt;code&gt;hillShade()&lt;/code&gt; function.
It requires previously created &lt;code&gt;slope&lt;/code&gt; and &lt;code&gt;aspect&lt;/code&gt; objects and setting two new arguments &lt;code&gt;angle&lt;/code&gt; and &lt;code&gt;direction&lt;/code&gt;.
The &lt;code&gt;angle&lt;/code&gt; argument is the elevation angle of the light source and the &lt;code&gt;direction&lt;/code&gt; argument is the direction (azimuth) angle of the light source (sun), both in degrees.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hill = hillShade(slope, aspect, angle = 40, direction = 270)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output object can be plotted with &lt;code&gt;plot(hill)&lt;/code&gt;, however, it does not give an expected map.
This is because the hillshade object should be overlayed by another semi-transparent layer to give a proper visualization.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;create-a-hillshade-map&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Create a hillshade map&lt;/h2&gt;
&lt;p&gt;A hillshade map can be created using the &lt;strong&gt;tmap&lt;/strong&gt; package.
This package builds maps by stacking different data layers.
In this case, the first layer is the hillshade object (&lt;code&gt;hill&lt;/code&gt;), colored using different levels of gray.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(hill) +
  tm_raster(palette = gray(0:10 / 10), style = &amp;quot;cont&amp;quot;, legend.show = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second layer is the elevation object (&lt;code&gt;alt&lt;/code&gt;), colored using the &lt;code&gt;terrain.colors&lt;/code&gt; palette.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(alt) +
  tm_raster(alpha = 0.5, palette = terrain.colors(10), style = &amp;quot;cont&amp;quot;,
            title = &amp;quot;Elevation (m asl)&amp;quot;, legend.show = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, both layers can be combined to create an expected visualization.
It could be also improved by placing the legend on the right bottom of the map.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(hill) +
  tm_raster(palette = gray(0:10 / 10), style = &amp;quot;cont&amp;quot;, legend.show = FALSE) +
  tm_shape(alt) +
  tm_raster(alpha = 0.5, palette = terrain.colors(10), style = &amp;quot;cont&amp;quot;,
            title = &amp;quot;Elevation (m asl)&amp;quot;, legend.show = TRUE) +
  tm_layout(legend.position = c(&amp;quot;RIGHT&amp;quot;, &amp;quot;BOTTOM&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Grids and graticules in the tmap package</title>
      <link>/post/2019/tmap-grid/</link>
      <pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/tmap-grid/</guid>
      <description>


&lt;p&gt;This vignette builds on the &lt;a href=&#34;https://geocompr.robinlovelace.net/adv-map.html&#34;&gt;making maps chapter&lt;/a&gt; of &lt;a href=&#34;https://geocompr.github.io/&#34;&gt;the Geocomputation with R book&lt;/a&gt;.
Its goal is to demonstrate how to set and modify grids and graticules in the &lt;strong&gt;tmap&lt;/strong&gt; package.&lt;/p&gt;
&lt;div id=&#34;prerequisites&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;The examples below assume the following packages are attached:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(spData) # example datasets
library(tmap)   # map creation (&amp;gt;=2.3)
library(sf)     # spatial data classes&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;grids-and-graticules&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Grids and graticules&lt;/h1&gt;
&lt;p&gt;The &lt;strong&gt;tmap&lt;/strong&gt; package offers two ways to draws coordinate lines - &lt;code&gt;tm_grid()&lt;/code&gt; and &lt;code&gt;tm_graticules()&lt;/code&gt;.
The role of &lt;code&gt;tm_grid()&lt;/code&gt; is to represent the input dataâ€™s coordinates.
For example, the &lt;code&gt;nz&lt;/code&gt; object uses the New Zealand Transverse Mercator projection, with meters as its units.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(nz) + 
  tm_polygons() +
  tm_grid()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tm_graticules()&lt;/code&gt; shows longitude lines (meridians) and latitude lines (parallels), with degrees as units (note the degree sign in the example below).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(nz) + 
  tm_polygons() +
  tm_graticules()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;layers-order&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Layers order&lt;/h1&gt;
&lt;p&gt;Both, &lt;code&gt;tm_grid()&lt;/code&gt; and &lt;code&gt;tm_graticules()&lt;/code&gt; could be placed above or below the main spatial data.
Its position on the map depends on its place in the code.
When &lt;code&gt;tm_grid()&lt;/code&gt; or &lt;code&gt;tm_graticules()&lt;/code&gt; are placed after the code drawing geometry (e.g.Â &lt;code&gt;tm_polygons()&lt;/code&gt;), the grids or graticules are ploted on the top of the map.
On the other hand, when &lt;code&gt;tm_grid()&lt;/code&gt; or &lt;code&gt;tm_graticules()&lt;/code&gt; are placed before the code drawing geometry (e.g.Â &lt;code&gt;tm_polygons()&lt;/code&gt;), the grids or graticules are plotted behind the spatial data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(nz) +
  tm_graticules() + 
  tm_polygons()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;customization&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Customization&lt;/h1&gt;
&lt;p&gt;Grids and graticules can be easily customized in &lt;strong&gt;tmap&lt;/strong&gt; using several arguments.
The first one, &lt;code&gt;labels.inside.frame&lt;/code&gt; moves the labels inside the map grid (it is set to &lt;code&gt;FALSE&lt;/code&gt; as the default).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(nz) +
  tm_grid(labels.inside.frame = TRUE) + 
  tm_polygons()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The number of horizontal (&lt;code&gt;x&lt;/code&gt;) and vertical (&lt;code&gt;y&lt;/code&gt;) lines can be set using the &lt;code&gt;n.x&lt;/code&gt; and &lt;code&gt;n.y&lt;/code&gt; arguments.
Importantly, &lt;strong&gt;tmap&lt;/strong&gt; rounds coordinate values to equally spaced â€œroundâ€ values, so the number of actual labels may be slightly different than set with &lt;code&gt;n.x&lt;/code&gt; and &lt;code&gt;n.y&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(nz) +
  tm_grid(n.x = 4, n.y = 3) + 
  tm_polygons()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;By default, &lt;code&gt;tm_grid()&lt;/code&gt; and &lt;code&gt;tm_graticules()&lt;/code&gt; shows ticks and lines.
They can be disabled using &lt;code&gt;ticks = FALSE&lt;/code&gt; and &lt;code&gt;lines = FALSE&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(nz) +
  tm_grid(ticks = FALSE) +
  tm_polygons()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Especially, &lt;code&gt;lines = FALSE&lt;/code&gt; could be useful when presenting raster data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(nz) +
  tm_grid(lines = FALSE) +
  tm_polygons()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It is also possible to customize &lt;code&gt;tm_grid()&lt;/code&gt; and &lt;code&gt;tm_graticules()&lt;/code&gt; apperance, for example by chaning the lines colors (&lt;code&gt;col&lt;/code&gt;), width (&lt;code&gt;lwd&lt;/code&gt;) or labels size (&lt;code&gt;labels.size&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(nz) +
  tm_grid(col = &amp;quot;red&amp;quot;, lwd = 3, labels.size = 0.4) +
  tm_polygons()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The above examples uses &lt;code&gt;tm_grid()&lt;/code&gt;, but the same arguments apply to the &lt;code&gt;tm_graticules()&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;layout-settings&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Layout settings&lt;/h1&gt;
&lt;p&gt;By default, &lt;strong&gt;tmap&lt;/strong&gt; adds small inner margins between the presented data and the map frame.
It works well in many cases, for example, see the map of New Zealand above.
However, it does not look perfect for world maps.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world) + 
  tm_graticules() + 
  tm_polygons()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The way to fix this is to use the &lt;code&gt;tm_layout()&lt;/code&gt; function and set its &lt;code&gt;inner.margins&lt;/code&gt; argument to &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(world) + 
  tm_graticules() + 
  tm_polygons() +
  tm_layout(inner.margins = 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/tmap-grid_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Geographic projections and transformations</title>
      <link>/post/2019/crs-projections-transformations/</link>
      <pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/crs-projections-transformations/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This workbook outlines key concepts and functions related to map projections â€” also referred to as coordinate reference systems (CRSs) â€” and transformation of geographic data from one projection to another.
It is based on the open source book &lt;a href=&#34;https://geocompr.robinlovelace.net&#34;&gt;&lt;em&gt;Geocomputation with R&lt;/em&gt;&lt;/a&gt;, and Chapter &lt;a href=&#34;https://geocompr.robinlovelace.net/reproj-geo-data.html&#34;&gt;6&lt;/a&gt; in particular.&lt;/p&gt;
&lt;p&gt;It was developed for the â€˜&lt;a href=&#34;https://bonnie-buyuklieva.github.io/SS_ASM19/&#34;&gt;CASA Summer School&lt;/a&gt;â€™, or the Doctoral Summer School for Advanced Spatial Modelling: Skills Workshop and Hackathon, 21&lt;sup&gt;st&lt;/sup&gt; to 23&lt;sup&gt;rd&lt;/sup&gt; August 2019, for its full name!
It should be of use to anyone interested in projections, beyond the summer school, so we posted it on our newly updated &lt;a href=&#34;https://geocompr.github.io/&#34;&gt;website&lt;/a&gt; for maximum benefit.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;prerequisites&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Prerequisites&lt;/h1&gt;
&lt;p&gt;Before you get started, make sure you have the packages installed:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)
library(dplyr)
library(spData)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;introduction-1&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Before we get started, why use R for geographic data?&lt;/p&gt;
&lt;p&gt;Simple answer: because it works, excels at spatial statistics and visualisation and has a huge user community.&lt;/p&gt;
&lt;p&gt;It can be used for a wide range of things such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Book on Geocomputation: &lt;a href=&#34;https://geocompr.robinlovelace.net/&#34; class=&#34;uri&#34;&gt;https://geocompr.robinlovelace.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Propensity to Cycle Tool: &lt;a href=&#34;https://pct.bike/&#34; class=&#34;uri&#34;&gt;https://pct.bike/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Geographic data relies on a frame of reference.
There are two main types of CRS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Geographic&lt;/strong&gt;, where the frame of reference is the globe and how many degrees north or east from the position (0, 0) you are&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Projected&lt;/strong&gt;, where the frame of reference is a flat representation of part of the Earthâ€™s surface&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:vectorplots&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://geocompr.robinlovelace.net/figures/vector_lonlat.png&#34; alt=&#34;Illustration of vector (point) data in which location of London (the red X) is represented with reference to an origin (the blue circle). The left plot represents a geographic CRS with an origin at 0Â° longitude and latitude. The right plot represents a projected CRS with an origin located in the sea west of the South West Peninsula.&#34; width=&#34;49%&#34; /&gt;&lt;img src=&#34;https://geocompr.robinlovelace.net/figures/vector_projected.png&#34; alt=&#34;Illustration of vector (point) data in which location of London (the red X) is represented with reference to an origin (the blue circle). The left plot represents a geographic CRS with an origin at 0Â° longitude and latitude. The right plot represents a projected CRS with an origin located in the sea west of the South West Peninsula.&#34; width=&#34;49%&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Illustration of vector (point) data in which location of London (the red X) is represented with reference to an origin (the blue circle). The left plot represents a geographic CRS with an origin at 0Â° longitude and latitude. The right plot represents a projected CRS with an origin located in the sea west of the South West Peninsula.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;tldr&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;TLDR&lt;/h1&gt;
&lt;p&gt;The â€˜too long didnâ€™t readâ€™ (TLDR) take away messages from this text are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Be aware of projections&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Decide an appropriate CRS for your project and ensure everything is in that CRS&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use a projected CRS when doing geometric operations&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EPSG codes such as 27700 and 4326 refer to specific coordinate systems&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;It is worth checking if there is an officially supported projection for the region â€” that is often a good option&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In R, you can check, set and transform CRS with &lt;code&gt;st_crs()&lt;/code&gt; and &lt;code&gt;st_transform()&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;zones_london = lnd
st_crs(zones_london)                                         # find out the CRS
#&amp;gt; Coordinate Reference System:
#&amp;gt;   User input: EPSG:4326 
#&amp;gt;   wkt:
#&amp;gt; GEOGCS[&amp;quot;WGS 84&amp;quot;,
#&amp;gt;     DATUM[&amp;quot;WGS_1984&amp;quot;,
#&amp;gt;         SPHEROID[&amp;quot;WGS 84&amp;quot;,6378137,298.257223563,
#&amp;gt;             AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;7030&amp;quot;]],
#&amp;gt;         AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;6326&amp;quot;]],
#&amp;gt;     PRIMEM[&amp;quot;Greenwich&amp;quot;,0,
#&amp;gt;         AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;8901&amp;quot;]],
#&amp;gt;     UNIT[&amp;quot;degree&amp;quot;,0.0174532925199433,
#&amp;gt;         AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;9122&amp;quot;]],
#&amp;gt;     AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;4326&amp;quot;]]
zones_london_projected = st_transform(zones_london, 27700)   # transform CRS
st_crs(zones_london) = NA                                    # set CRS
st_crs(zones_london) = 4326                                  # set CRS&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you ignore CRSs, bad things can happen.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;why-are-projections-needed&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Why are projections needed?&lt;/h1&gt;
&lt;p&gt;Without a coordinate system, we have no context:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Which country is it?&lt;/p&gt;
&lt;p&gt;Location on Earth is measured in degrees so, even when axes are equal, maps are highly distorted representations of reality far from the equator:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Along which axis is the image over-represented?&lt;/p&gt;
&lt;p&gt;Even when we compensate for this, the cylindrical projection is misleading:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;By default, most software (including R) plots data with geographic lon/lat coordinates a cylindrical projection, leading to maps like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(canada$geom)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(world)
#&amp;gt; Warning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot
#&amp;gt; all&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-5-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Across the whole world, the results look like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(st_geometry(world), col = &amp;quot;grey&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There is no single â€˜correctâ€™ CRS that can represent everywhere well: it is physically impossible to â€˜pealâ€™ the surface of the Earth onto a flat screen (credit: &lt;a href=&#34;https://unsplash.com/@awarnerway&#34;&gt;Awar Jahfar&lt;/a&gt;):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1564509398619-622e40ad5a5e?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=633&amp;amp;q=80&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;At best we can comply with two out of three spatial properties (distance, area, direction).
Therefore, the task at hand determines which projection to choose.
For instance, if we are interested in a density (points per grid cell or inhabitants per grid cell), we should use an equal-area projection.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;There is also a fourth property, shape.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;which-projection-to-use&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Which projection to use?&lt;/h1&gt;
&lt;p&gt;A range of CRSs is available:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Lambert azimuthal equal-area (&lt;a href=&#34;https://en.wikipedia.org/wiki/Lambert_azimuthal_equal-area_projection&#34;&gt;LAEA&lt;/a&gt;) projection for a custom local projection (set &lt;code&gt;lon_0&lt;/code&gt; and &lt;code&gt;lat_0&lt;/code&gt; to the center of the study area), which is an equal-area projection at all locations but distorts shapes beyond thousands of kilometers.&lt;/li&gt;
&lt;li&gt;Azimuthal equidistant (&lt;a href=&#34;https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection&#34;&gt;AEQD&lt;/a&gt;) projections for a specifically accurate straight-line distance between a point and the center point of the local projection.&lt;/li&gt;
&lt;li&gt;Lambert conformal conic (&lt;a href=&#34;https://en.wikipedia.org/wiki/Lambert_conformal_conic_projection&#34;&gt;LCC&lt;/a&gt;) projections for regions covering thousands of kilometers, with the cone set to keep distance and area properties reasonable between the secant lines.&lt;/li&gt;
&lt;li&gt;Stereographic (&lt;a href=&#34;https://en.wikipedia.org/wiki/Stereographic_projection&#34;&gt;STERE&lt;/a&gt;) projections for polar regions, but taking care not to rely on area and distance calculations thousands of kilometers from the center.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is how it works in R:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world_laea1_g = world %&amp;gt;%
  st_transform(&amp;quot;+proj=laea +x_0=0 +y_0=0 +lon_0=0 +lat_0=0&amp;quot;) %&amp;gt;% 
  st_geometry()
plot(world_laea1_g)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world %&amp;gt;%
  st_transform(&amp;quot;+proj=aeqd +x_0=0 +y_0=0 +lon_0=0 +lat_0=0&amp;quot;) %&amp;gt;% 
  st_geometry() %&amp;gt;% 
  plot()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world %&amp;gt;%
  st_transform(&amp;quot;+proj=moll&amp;quot;) %&amp;gt;% 
  st_geometry() %&amp;gt;% 
  plot()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;How to add graticules?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world %&amp;gt;%
  st_transform(&amp;quot;+proj=moll&amp;quot;) %&amp;gt;% 
  st_geometry() %&amp;gt;% 
  plot()
g = st_graticule(x = world) %&amp;gt;% 
  st_transform(&amp;quot;+proj=moll&amp;quot;) %&amp;gt;% 
  st_geometry()
plot(g, add = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;canada_centroid = st_coordinates(st_centroid(canada))
#&amp;gt; Warning in st_centroid.sf(canada): st_centroid assumes attributes are constant
#&amp;gt; over geometries of x
#&amp;gt; Warning in st_centroid.sfc(st_geometry(x), of_largest_polygon =
#&amp;gt; of_largest_polygon): st_centroid does not give correct centroids for longitude/
#&amp;gt; latitude data
canada_laea_crs = paste0(&amp;quot;+proj=laea +x_0=0 +y_0=0 +lon_0=&amp;quot;,
                         canada_centroid[1],
                         &amp;quot; +lat_0=&amp;quot;,
                         canada_centroid[2])
canada_laea = st_transform(canada, crs = canada_laea_crs)
world_laea = st_transform(world, crs = canada_laea_crs)
plot(st_geometry(canada_laea))
plot(world_laea, add = TRUE)
#&amp;gt; Warning in plot.sf(world_laea, add = TRUE): ignoring all but the first attribute&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;canada_centroid = st_coordinates(st_centroid(canada))
#&amp;gt; Warning in st_centroid.sf(canada): st_centroid assumes attributes are constant
#&amp;gt; over geometries of x
#&amp;gt; Warning in st_centroid.sfc(st_geometry(x), of_largest_polygon =
#&amp;gt; of_largest_polygon): st_centroid does not give correct centroids for longitude/
#&amp;gt; latitude data
canada_laea_crs = paste0(&amp;quot;+proj=laea +x_0=0 +y_0=0 +lon_0=&amp;quot;,
                         canada_centroid[1],
                         &amp;quot; +lat_0=&amp;quot;,
                         canada_centroid[2])
canada_laea = st_transform(canada, crs = canada_laea_crs)
world_laea = st_transform(world, crs = canada_laea_crs)
plot(st_geometry(canada_laea))
plot(world_laea, add = TRUE)
#&amp;gt; Warning in plot.sf(world_laea, add = TRUE): ignoring all but the first attribute&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;epsg-codes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;EPSG codes&lt;/h1&gt;
&lt;p&gt;EPSG codes are standard codes for projections.
See them in R with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;epsg_codes = rgdal::make_EPSG()
# View(epsg_codes) # open in interactive spreadsheet&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the UK, the EPSG code of official data is &lt;a href=&#34;https://epsg.io/27700&#34;&gt;27700&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;geographic-data-in-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Geographic data in R&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;london_df = data.frame(name = &amp;quot;london&amp;quot;, population = 1e7,
                       lon = -0.1, lat = 51.5)
class(london_df)
#&amp;gt; [1] &amp;quot;data.frame&amp;quot;
london = st_as_sf(london_df, coords = c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;))
class(london)
#&amp;gt; [1] &amp;quot;sf&amp;quot;         &amp;quot;data.frame&amp;quot;
st_is_longlat(london)
#&amp;gt; [1] NA
plot(zones_london_projected$geometry)
plot(london$geometry, add = TRUE, pch = 9) # not there&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;issues-with-geometric-operations&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Issues with geometric operations&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;london_buff1 = st_buffer(london, 0.1)
plot(london_buff1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(zones_london$geometry)
plot(london_buff1, add = T)
#&amp;gt; Warning in plot.sf(london_buff1, add = T): ignoring all but the first attribute&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-16-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;st_crs(london) = 4326
london_projected = st_transform(london, 27700)
london_buff2 = st_buffer(london_projected, 10000)
st_is_longlat(london_projected)
#&amp;gt; [1] FALSE
plot(zones_london_projected$geometry)
plot(london_buff2, add = TRUE)
#&amp;gt; Warning in plot.sf(london_buff2, add = TRUE): ignoring all but the first
#&amp;gt; attribute&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019/crs-projections-transformations_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;further-reading&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Further reading&lt;/h1&gt;
&lt;p&gt;If youâ€™re interested in learning more on this, check out &lt;em&gt;Geocomputations with R&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://geocompr.robinlovelace.net/&#34;&gt;&lt;img src=&#34;https://geocompr.robinlovelace.net/images/cover.png&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;More specific resources on projections include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Excellent tutorial on coordinate systems on the Manifold website: &lt;a href=&#34;http://www.manifold.net/doc/mfd9/projections_tutorial.htm&#34; class=&#34;uri&#34;&gt;http://www.manifold.net/doc/mfd9/projections_tutorial.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;An introduction to vector geographic data in &lt;em&gt;Geocomputation with R&lt;/em&gt; (Section &lt;a href=&#34;https://geocompr.robinlovelace.net/spatial-class.html#vector-data&#34;&gt;2.2&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;An introduction to CRSs in R (Section &lt;a href=&#34;https://geocompr.robinlovelace.net/spatial-class.html#crs-intro&#34;&gt;2.4&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;The contents and exercises of Chapter &lt;a href=&#34;https://geocompr.robinlovelace.net/reproj-geo-data.html&#34;&gt;6&lt;/a&gt;, solutions to which you can find at &lt;a href=&#34;https://geocompr.github.io/geocompkg/articles/index.html&#34; class=&#34;uri&#34;&gt;https://geocompr.github.io/geocompkg/articles/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;For a fun take on projections, see &lt;a href=&#34;https://xkcd.com/977/&#34; class=&#34;uri&#34;&gt;https://xkcd.com/977/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Chapter in upcoming book on CRSs by Edzer Pebesma and Roger Bivand: &lt;a href=&#34;https://github.com/edzer/sdsr&#34; class=&#34;uri&#34;&gt;https://github.com/edzer/sdsr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out the questions in the exercises section of Chapter 6 of Geocomputation with R.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Casting Geometries: Extended</title>
      <link>/post/2020/casting-geometries-extended/</link>
      <pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/casting-geometries-extended/</guid>
      <description>


&lt;p&gt;This vignette provides some further detail on the Type transformations section (see &lt;a href=&#34;https://geocompr.robinlovelace.net/geometric-operations.html#type-trans&#34; class=&#34;uri&#34;&gt;https://geocompr.robinlovelace.net/geometric-operations.html#type-trans&lt;/a&gt; ) of &lt;a href=&#34;https://geocompr.github.io/&#34;&gt;the Geocomputation with R book&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;attach-libraries&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Attach libraries&lt;/h1&gt;
&lt;p&gt;This vignette requires the following packages to be installed and attached:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)
library(purrr)
library(tibble)
library(dplyr)
library(tidyr)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;create-a-set-of-sfg-objects&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Create a set of sfg objects&lt;/h1&gt;
&lt;p&gt;The code below creates a set of simple feature geometries (&lt;code&gt;sfg&lt;/code&gt;) objects that are used as examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pts_sfg&lt;/code&gt; - POINT&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mpts_sfg&lt;/code&gt; - MULTIPOINT&lt;/li&gt;
&lt;li&gt;&lt;code&gt;line_sfg&lt;/code&gt; - LINESTRING&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mline_sfg&lt;/code&gt; - MULTILINESTRING&lt;/li&gt;
&lt;li&gt;&lt;code&gt;poly_sfg&lt;/code&gt; - POLYGON&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mpoly_sfg&lt;/code&gt; - MULTIPOLYGON&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geoc_sfg&lt;/code&gt; - GEOMETRYCOLLECTION&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, the &lt;code&gt;sfgs&lt;/code&gt; object - a list containing all of the above objects is created.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pts_sfg = st_point(c(5, 2))

multipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))
mpts_sfg = st_multipoint(multipoint_matrix)

linestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))
line_sfg = st_linestring(linestring_matrix)

multilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), 
                            rbind(c(1, 2), c(2, 4)))
mline_sfg = st_multilinestring((multilinestring_list))

polygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))
poly_sfg = st_polygon(polygon_list)

multipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),
                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))
mpoly_sfg = st_multipolygon(multipolygon_list)

gemetrycollection_list = list(st_multipoint(multipoint_matrix),
                              st_linestring(linestring_matrix))
geoc_sfg = st_geometrycollection(gemetrycollection_list)

sfgs = list(pts_sfg = pts_sfg, mpts_sfg = mpts_sfg,
            line_sfg = line_sfg, mline_sfg = mline_sfg, 
            poly_sfg = poly_sfg, mpoly_sfg = mpoly_sfg,
            geoc_sfg = geoc_sfg)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;create-a-set-of-sfc-objects&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Create a set of sfc objects&lt;/h1&gt;
&lt;p&gt;Next, all of the objects created above are converted to the simple feature columns (&lt;code&gt;sfc&lt;/code&gt;) class objects:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pts_sfc = st_sfc(pts_sfg)
mpts_sfc = st_sfc(mpts_sfg)
line_sfc = st_sfc(line_sfg)
mline_sfc = st_sfc((mline_sfg))
poly_sfc = st_sfc(poly_sfg)
mpoly_sfc = st_sfc(mpoly_sfg)
geoc_sfc = st_sfc(geoc_sfg)

sfcs = list(pts_sfc = pts_sfc, mpts_sfc = mpts_sfc,
            line_sfc = line_sfc, mline_sfc = mline_sfc, 
            poly_sfc = poly_sfc, mpoly_sfc = mpoly_sfc,
            geoc_sfc = geoc_sfc)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;create-a-set-of-sf-objects&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Create a set of sf objects&lt;/h1&gt;
&lt;p&gt;All of the &lt;code&gt;sfg&lt;/code&gt; objects are also converted to the simple feature (&lt;code&gt;sf&lt;/code&gt;) class objects:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_df = data.frame(col = &amp;quot;a&amp;quot;)
pts_sf = st_sf(my_df, pts_sfc)
mpts_sf = st_sf(my_df, mpts_sfc)
line_sf = st_sf(my_df, geom = line_sfc)
mline_sf = st_sf(my_df, geom = mline_sfc)
poly_sf = st_sf(my_df, geom = poly_sfc)
mpoly_sf = st_sf(my_df, geom = mpoly_sfc)
geoc_sf = st_sf(my_df, geom = geoc_sfc)

sfs = list(pts_sf = pts_sf, mpts_sf = mpts_sf,
           line_sf = line_sf, mline_sf = mline_sf, 
           poly_sf = poly_sf, mpoly_sf = mpoly_sf,
           geoc_sf = geoc_sf)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;plot-example-objects&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Plot example objects&lt;/h1&gt;
&lt;p&gt;Example object can be quickly plotted using the &lt;code&gt;plot()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mfrow = c(3, 3))
par(mar = c(3, 3, 1, 0))
plot(pts_sfc, axes = TRUE, main = &amp;quot;POINT&amp;quot;)
plot(mpts_sfc, axes = TRUE, main = &amp;quot;MULTIPOINT&amp;quot;)
plot(line_sfc, axes = TRUE, main = &amp;quot;LINESTRING&amp;quot;)
plot(mline_sfc, axes = TRUE, main = &amp;quot;MULTILINESTRING&amp;quot;)
plot(poly_sfc, axes = TRUE, main = &amp;quot;POLYGON&amp;quot;)
plot(mpoly_sfc, axes = TRUE, main = &amp;quot;MULTIPOLYGON&amp;quot;)
plot(geoc_sfc, axes = TRUE, main = &amp;quot;GEOMETRYCOLLECTION&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/casting-geometries-extended_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;480&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;create-st_cast-summary-functions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Create st_cast() summary functions&lt;/h1&gt;
&lt;p&gt;A new set of st_cast() summary functions is created below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;st_type()&lt;/code&gt; - returns a type of the input object, either &lt;code&gt;&#34;sfg&#34;&lt;/code&gt;, &lt;code&gt;&#34;sfc&#34;&lt;/code&gt;, &lt;code&gt;&#34;sf&#34;&lt;/code&gt;, or &lt;code&gt;NA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;st_geometry_type()&lt;/code&gt; - returns a geometry type of the input object, for example &lt;code&gt;MULTIPOLYGON&lt;/code&gt;.
It returns &lt;code&gt;NULL&lt;/code&gt; when the geometry type cannot be identified&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_s()&lt;/code&gt; - returns &lt;code&gt;NA&lt;/code&gt; when the input is &lt;code&gt;NULL&lt;/code&gt;, and unique values otherwise&lt;/li&gt;
&lt;li&gt;&lt;code&gt;st_caster()&lt;/code&gt; - it is the main function, based on all the previous ones.
Its returns a tibble showing what is an output when casting an input object to all of the possible geometry types&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;st_type = function(x){
  if (all(is.na(x))){
    return(NA)
  } 
  x_class = class(x)
  if (&amp;quot;sfg&amp;quot; %in% x_class){
    return(&amp;quot;sfg&amp;quot;)
  } else if (&amp;quot;sfc&amp;quot; %in% x_class){
    return(&amp;quot;sfc&amp;quot;)
  } else if (&amp;quot;sf&amp;quot; %in% x_class){
    return(&amp;quot;sf&amp;quot;)
  }
}
st_geometry_type_s = function(x){
  if (is.null(x)){
    return(NULL)
  } else {
    return(as.character(st_geometry_type(x)))
  }
}
unique_s = function(x) {
  ifelse(is.null(x), &amp;quot;NA&amp;quot;, unique(x))
}
st_caster = function(x){
  st_cast_s = possibly(st_cast, NULL)
  geometries_df = data_frame(to = c(&amp;quot;POINT&amp;quot;, &amp;quot;MULTIPOINT&amp;quot;, 
                                    &amp;quot;LINESTRING&amp;quot;, &amp;quot;MULTILINESTRING&amp;quot;,
                                    &amp;quot;POLYGON&amp;quot;, &amp;quot;MULTIPOLYGON&amp;quot;,
                                    &amp;quot;GEOMETRYCOLLECTION&amp;quot;))
  
  geo_df = geometries_df %&amp;gt;% 
    mutate(result = map(to, st_cast_s, x = x)) %&amp;gt;% 
    mutate(result_geom = map(result, st_geometry_type_s)) %&amp;gt;% 
    mutate(result_geom_length = map_int(result_geom, length)) %&amp;gt;% 
    mutate(result_geom = map_chr(result_geom, unique_s)) %&amp;gt;% 
    mutate(result_type = map_chr(result, st_type)) %&amp;gt;% 
    mutate(input = list(x)) %&amp;gt;% 
    mutate(input_geom = st_geometry_type_s(x)) %&amp;gt;% 
    mutate(input_geom_length = map_int(input_geom, length)) %&amp;gt;% 
    mutate(input_geom = map_chr(input_geom, unique_s)) %&amp;gt;% 
    mutate(input_type = st_type(x)) %&amp;gt;% 
    mutate(input_geom = paste0(input_geom, &amp;quot;(&amp;quot;, input_geom_length, &amp;quot;)&amp;quot;),
           result_geom = paste0(result_geom, &amp;quot;(&amp;quot;, result_geom_length, &amp;quot;)&amp;quot;)) %&amp;gt;% 
    dplyr::select(input_geom, to, result_geom_length) %&amp;gt;% 
    mutate(result_geom_length = if_else(result_geom_length == 0, NA_integer_, result_geom_length)) %&amp;gt;% 
    spread(to, result_geom_length)
  
  geo_df
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;prepare-summary-tables&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Prepare summary tables&lt;/h1&gt;
&lt;p&gt;Now, the example data is used as an input to the &lt;code&gt;st_caster()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sfgs_st_cast = sfgs %&amp;gt;% map_dfr(st_caster)
sfcs_st_cast = sfcs %&amp;gt;% map_dfr(st_caster)
sfs_st_cast = sfs %&amp;gt;% map_dfr(st_caster)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;summary-tables&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Summary tables&lt;/h1&gt;
&lt;p&gt;Finally, the summary tables are created, showing what happens when you cast geometry to another type for &lt;code&gt;sfg&lt;/code&gt;, &lt;code&gt;sfc&lt;/code&gt;, and &lt;code&gt;sf&lt;/code&gt; objects.&lt;/p&gt;
&lt;div id=&#34;sfg&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;sfg&lt;/h2&gt;
&lt;table&gt;
&lt;caption&gt;&lt;span id=&#34;tab:unnamed-chunk-8&#34;&gt;Table 1: &lt;/span&gt;Geometry casting on simple feature geometries with input type by row and output type by column. Values like (1) represent the number of features; NA means the operation is not possible.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;input_geom&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;POINT&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MULTIPOINT&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;LINESTRING&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MULTILINESTRING&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;POLYGON&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MULTIPOLYGON&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;GEOMETRYCOLLECTION&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;POINT(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;MULTIPOINT(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;LINESTRING(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;MULTILINESTRING(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;POLYGON(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;MULTIPOLYGON(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;GEOMETRYCOLLECTION(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;sfc&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;sfc&lt;/h2&gt;
&lt;table&gt;
&lt;caption&gt;&lt;span id=&#34;tab:unnamed-chunk-9&#34;&gt;Table 2: &lt;/span&gt;Geometry casting on simple feature geometry list columns with input type by row and output type by column. Values like (1) represent the number of features; NA means the operation is not possible.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;input_geom&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;POINT&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MULTIPOINT&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;LINESTRING&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MULTILINESTRING&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;POLYGON&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MULTIPOLYGON&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;GEOMETRYCOLLECTION&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;POINT(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;MULTIPOINT(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;LINESTRING(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;MULTILINESTRING(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;POLYGON(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;MULTIPOLYGON(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;GEOMETRYCOLLECTION(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;sf&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;sf&lt;/h2&gt;
&lt;table&gt;
&lt;caption&gt;&lt;span id=&#34;tab:unnamed-chunk-10&#34;&gt;Table 3: &lt;/span&gt;Geometry casting on simple features with input type by row and output type by column. Values like (1) represent the number of features; NA means the operation is not possible.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;input_geom&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;POINT&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MULTIPOINT&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;LINESTRING&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MULTILINESTRING&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;POLYGON&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MULTIPOLYGON&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;GEOMETRYCOLLECTION&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;POINT(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;MULTIPOINT(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;LINESTRING(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;MULTILINESTRING(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;POLYGON(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;MULTIPOLYGON(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;GEOMETRYCOLLECTION(1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Geocomputation benchmarks</title>
      <link>/post/2020/geocompr-benchmarks/</link>
      <pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/geocompr-benchmarks/</guid>
      <description>


&lt;div id=&#34;datasets-used&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Datasets used&lt;/h2&gt;
&lt;p&gt;The following filepaths datasets will be used:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f1 = system.file(&amp;quot;shapes/world.gpkg&amp;quot;, package = &amp;quot;spData&amp;quot;)
f2 = &amp;quot;promenade-all.geojson&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To run, this article relies on downloading files onto your computer:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(sf))
f2 = &amp;quot;promenade-all.geojson&amp;quot;
u = &amp;quot;https://github.com/spnethack/spnethack/releases/download/0.1/promenade-all.geojson&amp;quot;
if(!file.exists(f2)) download.file(u, destfile = f2)

system.time({b = read_sf(f2)})
system.time({d = b  %&amp;gt;% data.table::as.data.table()})
system.time(d[,geometry:=sf::st_as_text(geometry),])
system.time(d %&amp;gt;% readr::write_tsv(&amp;quot;tmp.tsv&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;reading-vector-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Reading vector data&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)
vector_filepath = system.file(&amp;quot;shapes/world.gpkg&amp;quot;, package = &amp;quot;spData&amp;quot;)
world = st_read(vector_filepath)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To demonstrate this, we will use a function to compare &lt;code&gt;st_read()&lt;/code&gt; with its &lt;strong&gt;sp&lt;/strong&gt; equivalent, &lt;code&gt;rgdal::readOGR()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1 = bench::mark(iterations = 3, check = FALSE,
            sf = st_read(vector_filepath),
            sp = rgdal::readOGR(vector_filepath)
)
b1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The benchmark ran on an input file (&lt;code&gt;file&lt;/code&gt;) and a number of times.
It shows that &lt;strong&gt;sf&lt;/strong&gt; was times faster than &lt;strong&gt;rgdal&lt;/strong&gt; at loading this file.&lt;/p&gt;
&lt;p&gt;The relative performance of &lt;code&gt;st_read()&lt;/code&gt; compared with other functions will vary depending on file format and the nature of the data.
To illustrate this point, we performed the same operation on a geojson file and found a greater speed saving:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;vector_filepath = system.file(&amp;quot;shapes/cycle_hire_osm.geojson&amp;quot;, package = &amp;quot;spData&amp;quot;)
b2 = bench::mark(iterations = 3, check = FALSE,
            sf = st_read(vector_filepath),
            sp = rgdal::readOGR(vector_filepath)
)
b2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case &lt;strong&gt;sf&lt;/strong&gt; was around times faster than &lt;strong&gt;rgdal&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;writing-vector-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Writing vector data&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rgdal)
world_sp = as(world, &amp;quot;Spatial&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system.time(writeOGR(world_sp, dsn = &amp;quot;world_sp.geojson&amp;quot;, layer = &amp;quot;world_sp.geojson&amp;quot;, driver = &amp;quot;GeoJSON&amp;quot;))
system.time(writeOGR(world_sp, dsn = &amp;quot;.&amp;quot;, layer = &amp;quot;world_sp&amp;quot;, driver = &amp;quot;ESRI Shapefile&amp;quot;)) 
system.time(writeOGR(world_sp, dsn = &amp;quot;world_sp.gpkg&amp;quot;, layer = &amp;quot;world_sp.gpkg&amp;quot;, driver = &amp;quot;GPKG&amp;quot;))
system.time(st_write(world, &amp;quot;world_sf.geojson&amp;quot;, quiet = TRUE))
system.time(st_write(world, &amp;quot;world_sf.shp&amp;quot;, quiet = TRUE)) 
system.time(st_write(world, &amp;quot;world_sf.gpkg&amp;quot;, quiet = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Geocomputation for sea level research</title>
      <link>/post/2020/sea-level-rise/</link>
      <pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/sea-level-rise/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Sea level rise (SLR) is a global phenemona whose impacts vary geographically.
Although the sea rises everywhere (although at different &lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/S0273117718305799&#34;&gt;rates&lt;/a&gt;), only certain, low-lying locations will be affected.
Sea level research involves analysing large geographic datasets and statistical models of change, making the computational approach advocated in &lt;em&gt;&lt;a href=&#34;https://geocompr.robinlovelace.net/&#34;&gt;Geocomputation with R&lt;/a&gt;&lt;/em&gt; well-suited to its study.&lt;/p&gt;
&lt;p&gt;The main factors determining the spatial distribution include elevation, proximity to the sea and population density: large, low-lying coastal settlements house the highest numbers of people at risk.
Land elevation, the height relative to geodesic reference points, is well known.
Although elevantion can change due to &lt;a href=&#34;https://en.wikipedia.org/wiki/Post-glacial_rebound&#34;&gt;glacial isostatic adjustment&lt;/a&gt;, the rate in places (less than 1mm/yr) is negligible compared with projected rates of SLR 21&lt;sup&gt;st&lt;/sup&gt; Century and beyond.&lt;/p&gt;
&lt;p&gt;How much the sea will rise in the next 10, 100, 1000 and even 10,000 years is a subject of scientific research.
One thing is for certain: the trend of rising sea levels, illustrated Figure 1, will continue (source: &lt;a href=&#34;https://climate.nasa.gov/vital-signs/sea-level/&#34;&gt;NASA&lt;/a&gt;).&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:slr&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://climate.nasa.gov/system/charts/12_seaLevel_left.gif&#34; alt=&#34;Figure 1: Historic sea level rise over the last century&#34; width=&#34;100%&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Figure 1: Historic sea level rise over the last century
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;In the long term, ice melt due to climate change means that SLR is likely to accelerate and flood many coastal areas.
One recent analysis suggests 50 m of SLR is likely in the next 10,000 years (note the units in the previous graph are mm, 1000 times less than a meter).
Much of that is likely to happen in the next 1,000 years &lt;span class=&#34;citation&#34;&gt;(Clark et al. 2016)&lt;/span&gt;, as illustrated in Figure 2:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unnamed-chunk-1&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/geocompr/geostats_18/master/images/slr-long-clark-et-al-2016.png&#34; alt=&#34;Figure 2: Future SLR projections over the next 10,000 years.&#34; width=&#34;100%&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: Figure 2: Future SLR projections over the next 10,000 years.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This vignette will download data for a city and analyse vulnerable areas based on the assumption of 10 m of sea level rise.
In the exercises you will be encouraged to re-run the analysis in different places and assuming different levels of SLR.
The first stage is setting up and reading in the data:&lt;/p&gt;
&lt;div id=&#34;set-up&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Set-up&lt;/h2&gt;
&lt;p&gt;We will use the following packages:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)
library(tmap)
library(dplyr)
library(raster)
library(spDataLarge)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A file representing global elevation can be downloaded and read-in as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if(!file.exists(&amp;quot;e.tif&amp;quot;))
  download.file(&amp;quot;https://github.com/geocompr/geocompkg/releases/download/0.1/e.tif&amp;quot;,
  &amp;quot;e.tif&amp;quot;)
elev = raster(&amp;quot;e.tif&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The global population data we will use can be summarised as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;urban = spData::urban_agglomerations %&amp;gt;% 
  filter(year == 2030) %&amp;gt;% 
  dplyr::select(population_millions) 
summary(urban)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  population_millions          geometry 
##  Min.   :11.71       POINT        :30  
##  1st Qu.:15.81       epsg:4326    : 0  
##  Median :18.12       +proj=long...: 0  
##  Mean   :20.15                         
##  3rd Qu.:24.04                         
##  Max.   :38.94&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have 30 points. These can be overlaid on the raster image as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tm_shape(elev) +
  tm_raster(breaks = c(-10000, 0, 10, 50, 100, 10000)) +
  tm_shape(urban) +
  tm_dots(size = &amp;quot;population_millions&amp;quot;, scale = 0.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Variable(s) &amp;quot;e&amp;quot; contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/sea-level-rise_files/figure-html/slr-map1-1.png&#34; width=&#34;100%&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vector data
plot(spData::world)
poland = dplyr::filter(spData::world, grepl(pattern = &amp;quot;Pola&amp;quot;, name_long))
plot(st_geometry(poland))
# testing elevatr (from readme / vignette)
# data(lake)
# elevation_high = get_elev_raster(lake, z = 14, src = &amp;quot;aws&amp;quot;)
# 120 MB&amp;quot;
# elevation = get_elev_raster(lake, z = 9, src = &amp;quot;aws&amp;quot;)
# elevation_low = get_elev_raster(lake, z = 4, src = &amp;quot;aws&amp;quot;)
# pryr::object_size(elevation)
# pryr::object_size(elevation_low)
# plot(elevation_low)
# mapview::mapview(elevation_low)
# cols = rainbow(5)
# plot(elevation, add = T, col = cols)

# getting a map of the szczecin coastline
# option 1 - via osmdata:
# library(osmdata)
# region = osmdata::getbb(place_name = &amp;quot;cardiff uk&amp;quot;, format_out = &amp;quot;sf_polygon&amp;quot;)
# region = getbb(place_name = &amp;quot;cardiff uk&amp;quot;, format_out = &amp;quot;sf_polygon&amp;quot;)
# sf::st_write(region, &amp;quot;data/scz-osm.geojson&amp;quot;)
region = sf::read_sf(&amp;quot;data/scz-osm.geojson&amp;quot;)
(m = mapview::mapview(region)) # not quite what I was after, but a good start

# option 2 - via (new+improved) mapedit
# region_mapedit = mapedit::drawFeatures(map = m)
# sf::write_sf(region_mapedit, &amp;quot;data/scz-mapedit.geojson&amp;quot;)
region_mapedit = sf::read_sf(&amp;quot;data/scz-mapedit.geojson&amp;quot;)
plot(region_mapedit)
region_sp = as(region, &amp;quot;Spatial&amp;quot;)
# e = elevatr::get_elev_raster(locations = region_sp, z = 8, src = &amp;quot;aws&amp;quot;)
# raster::writeRaster(x = e, filename = &amp;quot;data/scz-elev-z5.tif&amp;quot;)
e = raster(&amp;quot;data/scz-elev-z5.tif&amp;quot;)
x_crs = st_crs(27700)
e_projected = raster::projectRaster(e, crs = x_crs$proj4string)
e_projected

# get points less than 10m above slr
e_mask = e_low = e &amp;lt; 10
plot(e_low)
plot(spData::world, add = T, col = NA)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;analysis&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e_mask[e &amp;gt; 10] = NA
e_low = mask(e, e_mask)
mapview::mapview(e_low)
# out-takes
# e = raster::getData(name = &amp;quot;SRTM&amp;quot;, lon = c(-180, 180), lat = c(-60, 60))
# writeRaster(e_low, &amp;quot;scz-elev-low.tif&amp;quot;)

system.time({
  r_orig = raster::raster(&amp;quot;data/20180816184319_429977190-14-degrees-polish-coast.tif&amp;quot;)
  plot(r_orig)
  })
summary(r_orig)
r_agg = aggregate(r_orig, 100)
res(r_agg)
res(e)
plot(r_agg)
plot(e_low, add = T)
e_resampled = raster::resample(e, r_agg)
plot(values(r_agg), values(e_resampled))
cor(values(r_agg), values(e_resampled))^2

# r = extend(r_agg, e)
# r_low = mask(r, e_mask)

# proportion of region that is at risk from slr
e_low_crop = crop(e_low, scz)
plot(e_low_crop)
e_low_sf = spex::polygonize(e_low_crop)
e_low_intersect = st_intersection(e_low_sf, scz)
plot(scz)
plot(e_low_sf, add = T)
plot(e_low_intersect, add = TRUE, col = &amp;quot;blue&amp;quot;)
sum(st_area(e_low_intersect)) / st_area(scz)


# publish
scz_buff = st_buffer(scz, dist = 0)
library(tmap)
scz$col = &amp;quot;red&amp;quot;
m = tm_shape(e_low) +
  tm_raster(alpha = 0.5) +
  tm_shape(scz_buff) + # not working...
  tm_fill(col = &amp;quot;red&amp;quot;) +
  tm_shape(e_low_intersect) +
  tm_polygons() +
  tm_shape(poland) +
  tm_borders()
m
m2 = mapview::mapview(e_low) + scz
m2
tmap_save(m, &amp;quot;/home/robin/repos/geostats_18/data/scz-map.html&amp;quot;)
browseURL(&amp;quot;data/scz-map.html&amp;quot;)

# elevation data around prague
# prague = osmdata::getbb(&amp;quot;prague&amp;quot;, format_out = &amp;quot;sf_polygon&amp;quot;)
# plot(prague)
# write_sf(prague, &amp;quot;data/prague.geojson&amp;quot;)
# prague_elev = get_elev_raster(as(prohonice, &amp;quot;Spatial&amp;quot;), z = 9, src = &amp;quot;aws&amp;quot;)
# writeRaster(prague_elev, &amp;quot;data/prague_elev.tif&amp;quot;)
prague = read_sf(&amp;quot;data/prague.geojson&amp;quot;)
prague_elev = raster::raster(&amp;quot;data/prague_elev.tif&amp;quot;)
plot(prague_elev)
plot(prague, add = TRUE)
# mapview::mapview(prague_elev) +
#   mapview::mapview(prague)

# # detour: finding the resolution:
# p = stplanr::geo_select_aeq(shp = scz_mapedit)
# e_projected = projectRaster(e, crs = p$proj4string)
# summary(e)
# res(e)
# res(e_projected)
# e1 = crop(e, extent(e, 1, 2, 1, 2)) 
# values(e1) = 1:4
# plot(e1)
# e1xy = raster::xyFromCell(e1, cell = 1:ncell(e1))
# e1df = as.data.frame(e1xy)
# e1p = st_as_sf(e1df, coords = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;), crs = 4326)
# plot(e1p[1:2, ], cex = 5)
# st_distance(e1p[1, ], e1p[2, ]) # 1.37 km res. (x), 1.49 km res (y) 
# st_distance(e1p[1, ], e1p[3, ]) # 1.37 km res. (x), 1.49 km res (y) 
# 
# # detour: raster -&amp;gt; vector conversion
# e_low_crop = crop(e_low, scz)
# plot(e_low_crop)
# e_low_scz = spPolygons(e_low_crop)
# plot(e_low_scz) # interesting
# class(e_low_scz)
# e_low_sf = st_as_sf(e_low_scz)
# plot(e_low_sf, col = &amp;quot;red&amp;quot;) # modern art!&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;exercises&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Exercises&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Use your geocompuational skills to create a reproducible study of the spatial distribution of the impacts of sea level rise, based on assumptions of 2m, 10m and a worst-case 50m scenario of change.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-clark_consequences_2016&#34;&gt;
&lt;p&gt;Clark, Peter U., Jeremy D. Shakun, Shaun A. Marcott, Alan C. Mix, Michael Eby, Scott Kulp, Anders Levermann, et al. 2016. â€œConsequences of Twenty-First-Century Policy for Multi-Millennial Climate and Sea-Level Change.â€ &lt;em&gt;Nature Climate Change&lt;/em&gt;, February. &lt;a href=&#34;https://doi.org/10.1038/nclimate2923&#34;&gt;https://doi.org/10.1038/nclimate2923&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Loading and analyzing GPS tracks with R</title>
      <link>/post/2020/gps-tracks/</link>
      <pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/gps-tracks/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Perhaps the most ubiquitous type of geographic information is the continuous stream of data produced by GPS devices.
Global Positioning System (GPS) devices are now in everything from watches to cars and, of course, smartphones.
This means that GPS datasets have the ability to track a large proportion of the worldâ€™s population.
Although there are privacy concerns, when appropriately anonymized and aggregated, GPS datasets have the potential to help tackle the issues raised in &lt;a href=&#34;https://geocompr.robinlovelace.net/transport.html&#34;&gt;the Transportation chapter&lt;/a&gt; of &lt;a href=&#34;https://geocompr.github.io/&#34;&gt;the Geocomputation with R book&lt;/a&gt;:
to design healthy transport systems in which walking and cycling overtake cars as the main travel modes.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;loading-gps-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Loading GPS data&lt;/h2&gt;
&lt;p&gt;The standard format of GPS data is the &lt;a href=&#34;https://en.wikipedia.org/wiki/GPS_Exchange_Format&#34;&gt;.gpx file&lt;/a&gt;.
GPS traces are vector datasets that are well-support by &lt;strong&gt;sf&lt;/strong&gt; (see Chapter &lt;a href=&#34;https://geocompr.robinlovelace.net/spatial-class.html&#34;&gt;2&lt;/a&gt; of the book), so weâ€™ll use this package to process them:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)
#&amp;gt; Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 7.0.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As with any dataset the first stage is to identify the source.
A great source of GPS data is OpenStreetMap (OSM).
Weâ€™ll use publicly available .gpx files uploaded to OSM as the basis of this tutorial.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
For the purpose of this tutorial we will use a .gpx file uploaded to OSM, that represents travel to the &lt;a href=&#34;https://www.uni-muenster.de/Geoinformatics/en/&#34;&gt;Institute for Geoinformatics, UniversitÃ¤t MÃ¼nster&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;u = &amp;quot;https://www.openstreetmap.org/trace/2886173/data&amp;quot;
download.file(url = u, destfile = &amp;quot;trace.gpx&amp;quot;)
st_layers(&amp;quot;trace.gpx&amp;quot;)
#&amp;gt; Driver: GPX 
#&amp;gt; Available layers:
#&amp;gt;     layer_name     geometry_type features fields
#&amp;gt; 1    waypoints             Point        0     23
#&amp;gt; 2       routes       Line String        0     12
#&amp;gt; 3       tracks Multi Line String        1     13
#&amp;gt; 4 route_points             Point        0     25
#&amp;gt; 5 track_points             Point      225     26&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The previous code chunk downloads the trace from OSM and queries the â€˜layersâ€™ that can be imported (note there are 5, but only â€˜tracksâ€™ and â€˜track_pointsâ€™ are available).
The following code chunk imports and plots the â€˜tracksâ€™ layer, which is a MULTILINESTRING geometry in sf, and only 1 row of data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;r = st_read(&amp;quot;trace.gpx&amp;quot;, layer = &amp;quot;tracks&amp;quot;)
#&amp;gt; Reading layer `tracks&amp;#39; from data source `/home/runner/work/geocompr.github.io/geocompr.github.io/content/post/2020/trace.gpx&amp;#39; using driver `GPX&amp;#39;
#&amp;gt; Simple feature collection with 1 feature and 13 fields
#&amp;gt; geometry type:  MULTILINESTRING
#&amp;gt; dimension:      XY
#&amp;gt; bbox:           xmin: 7.595836 ymin: 51.95356 xmax: 7.640715 ymax: 51.96967
#&amp;gt; geographic CRS: WGS 84
class(r)
#&amp;gt; [1] &amp;quot;sf&amp;quot;         &amp;quot;data.frame&amp;quot;
st_geometry_type(r)
#&amp;gt; [1] MULTILINESTRING
#&amp;gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE
nrow(r)
#&amp;gt; [1] 1
plot(r$geometry)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/gps-tracks_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Other than the geometry, this object has limited information about the route in the fields.
The richest field is â€˜Descriptionâ€™, which contains the following summary data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class(r$desc)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[1] â€œfactorâ€&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.character(r$desc)&lt;/code&gt;&lt;/pre&gt;
[1] &#34;
&lt;p&gt;
Start time: 01/07/2019 10:03&lt;br/&gt;Finish time: 01/07/2019 10:34&lt;br/&gt;Distance: 5.1 km (00:30)&lt;br/&gt;Moving time: 00:21&lt;br/&gt;Average speed: 10.08 km/h&lt;br/&gt;Avg. Speed Mov.: 14.07 km/h&lt;br/&gt;Max. speed: 35.06 km/h&lt;br/&gt;Minimum altitude: 32 m&lt;br/&gt;Maximum altitude: 68 m&lt;br/&gt;Ascent speed: 469.6 m/h&lt;br/&gt;Descent speed: -889.1 m/h&lt;br/&gt;Elevation gain: 139 m&lt;br/&gt;Elevation loss: -113 m&lt;br/&gt;Ascent time: 00:17&lt;br/&gt;Descent time: 00:07&lt;br/&gt;
&lt;/p&gt;
&lt;hr align=\&#34;center\&#34; width=\&#34;480\&#34; style=\&#34;height: 2px; width: 517px\&#34;/&gt;
&lt;p&gt;&#34;&lt;/p&gt;
&lt;p&gt;The data can also be imported as points, as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p = read_sf(&amp;quot;trace.gpx&amp;quot;, layer = &amp;quot;track_points&amp;quot;)
plot(p)
#&amp;gt; Warning: plotting the first 9 out of 26 attributes; use max.plot = 26 to plot
#&amp;gt; all
#&amp;gt; Warning in min(x): no non-missing arguments to min; returning Inf
#&amp;gt; Warning in max(x): no non-missing arguments to max; returning -Inf
#&amp;gt; Warning in min(x): no non-missing arguments to min; returning Inf
#&amp;gt; Warning in max(x): no non-missing arguments to max; returning -Inf&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/gps-tracks_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;time-series&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Time series&lt;/h2&gt;
&lt;p&gt;When did the track take place?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(p$time)
#&amp;gt;                  Min.               1st Qu.                Median 
#&amp;gt; &amp;quot;2019-01-07 09:03:22&amp;quot; &amp;quot;2019-01-07 09:15:31&amp;quot; &amp;quot;2019-01-07 09:19:29&amp;quot; 
#&amp;gt;                  Mean               3rd Qu.                  Max. 
#&amp;gt; &amp;quot;2019-01-07 09:20:02&amp;quot; &amp;quot;2019-01-07 09:24:24&amp;quot; &amp;quot;2019-01-07 09:34:01&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It started from just after 9:00 in the morning and ended just after 09:30.
Letâ€™s check if they happened at regular intervals:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(p$time, 1:nrow(p))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/gps-tracks_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And the temporal resolution:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;difftime(p$time[11], p$time[10])
#&amp;gt; Time difference of 4 secs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;converting-points-to-lines&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Converting points to lines&lt;/h2&gt;
&lt;p&gt;The plot of points is useful, but it would be better to have a line representation &lt;em&gt;that contains the rich point-level data&lt;/em&gt;.
This can be done by converting the points to lines, as follows for the the first 2 points:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c = st_coordinates(p)
l1 = sf::st_linestring(c[1:2, ])
plot(l1)
lsf = st_sf(st_set_geometry(p[2, ], NULL), st_sfc(l1))
plot(p$geometry[1:2], add = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/gps-tracks_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For all points we can do:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;points2line_trajectory = function(p) {
  c = st_coordinates(p)
  i = seq(nrow(p) - 2)
  l = purrr::map(i, ~ sf::st_linestring(c[.x:(.x + 1), ]))
  s = purrr::map_dbl(i, function(x) {
    geosphere::distHaversine(c[x, ], c[(x + 1), ]) /
      as.numeric(p$time[x + 1] - p$time[x])
  }
  )
  lfc = sf::st_sfc(l)
  a = seq(length(lfc)) + 1 # sequence to subset
  p_data = cbind(sf::st_set_geometry(p[a, ], NULL), s)
  sf::st_sf(p_data, geometry = lfc)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Letâ€™s test it out:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;l = points2line_trajectory(p)
plot(l)
#&amp;gt; Warning: plotting the first 10 out of 27 attributes; use max.plot = 27 to plot
#&amp;gt; all
#&amp;gt; Warning in min(x): no non-missing arguments to min; returning Inf
#&amp;gt; Warning in max(x): no non-missing arguments to max; returning -Inf
#&amp;gt; Warning in min(x): no non-missing arguments to min; returning Inf
#&amp;gt; Warning in max(x): no non-missing arguments to max; returning -Inf&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/gps-tracks_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We now have lots more variables to play with and, unlike with the point dataset, the look good (and like traces) when plotted.
Note that in the previous function definition we calculated speed.
Plot the resulting â€˜speed profile traceâ€™ as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(l[&amp;quot;s&amp;quot;], lwd = l$s)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020/gps-tracks_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;further-resources&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Further resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Content on trajectories by Edzer Pebesma: &lt;a href=&#34;http://edzer.github.io/astd/lec8.html&#34; class=&#34;uri&#34;&gt;http://edzer.github.io/astd/lec8.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;trajectories&lt;/strong&gt; package:
&lt;a href=&#34;https://cran.r-project.org/package=trajectories&#34; class=&#34;uri&#34;&gt;https://cran.r-project.org/package=trajectories&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;trajr&lt;/strong&gt; package: &lt;a href=&#34;https://cran.rstudio.com/web/packages/trajr/vignettes/trajr-vignette.html&#34; class=&#34;uri&#34;&gt;https://cran.rstudio.com/web/packages/trajr/vignettes/trajr-vignette.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;trackeR&lt;/strong&gt; package: &lt;a href=&#34;https://github.com/trackerproject/trackeR&#34; class=&#34;uri&#34;&gt;https://github.com/trackerproject/trackeR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The SpatioTemporal task view: &lt;a href=&#34;https://cran.r-project.org/web/views/SpatioTemporal.html&#34; class=&#34;uri&#34;&gt;https://cran.r-project.org/web/views/SpatioTemporal.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- # Larger track datasets --&gt;
&lt;!-- 6 MB --&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;
For saving your own GPS data, we recommend using an open source Android apps such as &lt;a href=&#34;https://www.oruxmaps.com/cs/en/&#34;&gt;Orux&lt;/a&gt;, &lt;a href=&#34;https://github.com/owntracks/android&#34;&gt;owntracks&lt;/a&gt; or &lt;a href=&#34;https://osmand.net/features/trip-recording-plugin&#34;&gt;osmand&lt;/a&gt;.
These can then be transferred onto your computer and, if you want to support the community, uploaded to OSM.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;â†©ï¸Ž&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Spatial Subsetting: Extended</title>
      <link>/post/2020/spatial-subsetting-extended/</link>
      <pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/spatial-subsetting-extended/</guid>
      <description>


&lt;p&gt;This vignette provides some further detail on the vector attribute subsetting section (see &lt;a href=&#34;https://geocompr.robinlovelace.net/attr.html#vector-attribute-subsetting&#34; class=&#34;uri&#34;&gt;https://geocompr.robinlovelace.net/attr.html#vector-attribute-subsetting&lt;/a&gt; ) and the spatial subsetting section (see &lt;a href=&#34;https://geocompr.robinlovelace.net/spatial-operations.html#spatial-subsetting&#34; class=&#34;uri&#34;&gt;https://geocompr.robinlovelace.net/spatial-operations.html#spatial-subsetting&lt;/a&gt; ) of &lt;a href=&#34;https://geocompr.github.io/&#34;&gt;the Geocomputation with R book&lt;/a&gt;.
Its goal is to demonstrate some subtleties of spatial subsetting of &lt;code&gt;sf&lt;/code&gt; objects using base R and &lt;strong&gt;tidyverse&lt;/strong&gt; methods.&lt;/p&gt;
&lt;p&gt;The starting point is to attach necessary packages:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;knitr::opts_chunk$set(eval = FALSE) # failing currently (2020-03) so not running (RL)
# Error:
#   Quitting from lines 205-218 (spatial-subsetting-extended.Rmd) 
# Error: Must subset rows with a valid subscript vector.
# âœ– Subscript `i` must be a simple vector, not a matrix.
library(sf)
library(spData)
library(dplyr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And subsetting canterbury and &lt;code&gt;nz_height&lt;/code&gt; features in the region:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;canterbury = nz %&amp;gt;% filter(Name == &amp;quot;Canterbury&amp;quot;)
canterbury_height = nz_height[canterbury, ]&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;subsetting-with-intermediary-objects&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Subsetting with intermediary objects&lt;/h2&gt;
&lt;p&gt;We can see how to get a list representation for subsetting:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sel_sgbp = st_intersects(x = nz_height, y = canterbury)
class(sel_sgbp)
sel_logical = lengths(sel_sgbp) &amp;gt; 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above code chunk, an object of class &lt;code&gt;sgbp&lt;/code&gt; is created and then converted into a logical vector &lt;code&gt;sel_logical&lt;/code&gt;.
Values of TRUE in &lt;code&gt;sel_logical&lt;/code&gt; represents points from &lt;code&gt;nz_height&lt;/code&gt; that intersects with the &lt;code&gt;canterbury&lt;/code&gt; polygon.
In other words, it returns elevation points located in the Canterbury region.&lt;/p&gt;
&lt;p&gt;Use the result using base R:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;canterbury_height2 = nz_height[sel_logical, ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And use the result with the tidyverse:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;canterbury_height3 = nz_height %&amp;gt;% filter(sel_logical)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;dplyr-changes-row-names&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;strong&gt;dplyr&lt;/strong&gt; changes row names&lt;/h2&gt;
&lt;p&gt;We can test whether the subsetted objects are identical as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;identical(x = canterbury_height, y = canterbury_height2)
identical(x = canterbury_height, y = canterbury_height3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is different about &lt;code&gt;canterbury_height3&lt;/code&gt;?
The only difference is that &lt;code&gt;filter()&lt;/code&gt; changed the row names:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;row.names(canterbury_height)[1:3]
row.names(canterbury_height3)[1:3]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the row names are re-set, the objects become identical:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attr(canterbury_height3, &amp;quot;row.names&amp;quot;) = attr(x = canterbury_height, &amp;quot;row.names&amp;quot;)
identical(canterbury_height, canterbury_height3)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;rmdnote&#34;&gt;
&lt;p&gt;
This discarding of row names is not something that is specific to spatial data, as illustrated in the code chunk below. &lt;strong&gt;dplyr&lt;/strong&gt; discards row names by design. For further discussion of this decision, and some controversy, see the (closed) issue &lt;a href=&#34;https://github.com/tidyverse/dplyr/issues/366&#34;&gt;#366&lt;/a&gt; in the packageâ€™s issue tracker.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;dense-matrices-from-spatial-predicates&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Dense matrices from spatial predicates&lt;/h2&gt;
&lt;p&gt;In the code below a dense matrix is created.
&lt;code&gt;sel&lt;/code&gt; is not, as one might imagine, a &lt;code&gt;logical&lt;/code&gt; &lt;code&gt;vector&lt;/code&gt; (although it behaves as one as it only has one column) but a &lt;code&gt;logical&lt;/code&gt; &lt;code&gt;matrix&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sel = st_intersects(nz_height, canterbury, sparse = FALSE)
class(sel)
typeof(sel)
dim(sel)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The dimensions of &lt;code&gt;sel&lt;/code&gt; (returned by the base R command &lt;code&gt;dim()&lt;/code&gt;) show one row per feature in the target object (&lt;code&gt;nz_height&lt;/code&gt;) and a column per feature in the subsetting object (&lt;code&gt;canterbury&lt;/code&gt;).
The general pattern here is that &lt;code&gt;sel[i, j]&lt;/code&gt; is &lt;code&gt;TRUE&lt;/code&gt; if the i&lt;sup&gt;th&lt;/sup&gt; feature in the target object intersects with the j&lt;sup&gt;th&lt;/sup&gt; feature in the subsetting object.
If there is more than one feature in &lt;code&gt;y&lt;/code&gt; the resulting selection &lt;code&gt;matrix&lt;/code&gt; must be converted into a &lt;code&gt;vector&lt;/code&gt; before it is used for subsetting, e.g.Â with &lt;code&gt;rowSums(sel_matrix) &amp;gt; 0&lt;/code&gt;.
Another solution is to convert the default sparse matrix (&lt;code&gt;list&lt;/code&gt;) output from &lt;code&gt;st_intersects()&lt;/code&gt; to a &lt;code&gt;logical&lt;/code&gt; vector using the function &lt;code&gt;lengths()&lt;/code&gt;.
This approach to spatial subsetting, used internally by &lt;strong&gt;sf&lt;/strong&gt; (see the source code of &lt;code&gt;sf:::`[.sf`&lt;/code&gt;), is illustrated in the code chunk below:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;co = filter(nz, grepl(&amp;quot;Canter|Otag&amp;quot;, Name))
sel_sparse = st_intersects(nz_height, co)
sel_vector = lengths(sel_sparse) &amp;gt; 0
heights_co = nz_height[sel_vector, ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code chunk results in an object, &lt;code&gt;heights_co&lt;/code&gt;, that represents the high points that intersect with either Canterbury &lt;em&gt;or&lt;/em&gt; Otago region (hence the object name &lt;code&gt;co&lt;/code&gt;).
It did this in four stages:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Subset the regions of &lt;code&gt;nz&lt;/code&gt; containing â€œCanterâ€ or â€œOtagoâ€ in their names. This was done using the pattern matching function &lt;code&gt;grepl()&lt;/code&gt; in combination with the &lt;code&gt;|&lt;/code&gt; character, which means â€˜orâ€™, resulting in the subsetting object &lt;code&gt;co&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create a sparse geometry binary predicate &lt;code&gt;sgbp&lt;/code&gt; object, a list representing which features of &lt;code&gt;nz_height&lt;/code&gt; intersect with the regions in &lt;code&gt;co&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Convert the selection list into a &lt;code&gt;logical&lt;/code&gt; â€˜selection vectorâ€™. &lt;code&gt;lengths()&lt;/code&gt; finds the features in &lt;code&gt;nz_height&lt;/code&gt; matching &lt;em&gt;any&lt;/em&gt; features in &lt;code&gt;co&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Use the result to subset &lt;code&gt;nz_heights&lt;/code&gt;, creating a new object &lt;code&gt;heights_co&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;more-on-subsetting-in-base-r&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;More on subsetting in base R&lt;/h2&gt;
&lt;p&gt;Another spatial subsetting example will use an object representing the countries of Africa, created using attribute subsetting as follows:&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;africa_wgs = world %&amp;gt;% filter(continent == &amp;quot;Africa&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To further prepare the input data, we will reproject the data to the coordinate reference system (CRS) 32630, its EPSG code (explained in &lt;a href=&#34;https://geocompr.robinlovelace.net/reproj-geo-data.html&#34;&gt;Chapter 6&lt;/a&gt;):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;africa = st_transform(africa_wgs, crs = 32630)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also use the &lt;code&gt;[&lt;/code&gt; operator for &lt;em&gt;Spatial&lt;/em&gt; subsetting.
The difference is that we use &lt;em&gt;another spatial object&lt;/em&gt; inside the square brackets instead of an &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt; vector.
This is a concise and consistent syntax, as shown in the next code chunk.
Letâ€™s test it with a hypothetical scenario: we want to subset all countries within 2000 km of the point where the equator (where latitude = 0 degrees) intersects the prime meridian (longitude = 0 degrees), as illustrated in the next figure.
The subsetting object is created below.
Note that this must have the same CRS as the target object (set with the &lt;code&gt;crs&lt;/code&gt; argument):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;center_wgs = st_sf(geometry = st_sfc(st_point(c(0, 0)), crs = 4326))
center = st_transform(center_wgs, 32630)
buff = st_buffer(center, dist = 2e6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The data to be subset, or â€˜target layerâ€™, is the &lt;code&gt;africa&lt;/code&gt; object created above, which has a projected CRS (&lt;code&gt;32630&lt;/code&gt;).
Subsequently, spatial subsetting can be done with a single, concise command:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;africa_buf = africa[buff, ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Sidenote:&lt;/strong&gt; If we were using geographic (â€˜lon/latâ€™) data the previous command would have emitted a message warning about assuming &lt;code&gt;planar coordinates&lt;/code&gt;.
This is because spatial operations (especially distance and area calculations) cannot be assumed to be accurate in a geographic (longitude/latitude) CRS.
In this case one could justify the use of a lon/lat CRS: the data is close to the equator where there is least distortion caused by the curvature of the earth.
It is good practice to reproject spatial datasets before performing spatial operations on them.&lt;/p&gt;
&lt;p&gt;The spatial subsetting clearly worked: only countries intersecting with the giant circle are returned (see the figure below):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(africa_buf[&amp;quot;pop&amp;quot;], reset = FALSE)
plot(buff, add = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that countries that just touch the giant circle are selected such as Chad (northeast of the circle).
This is because the default subsetting operator is &lt;code&gt;st_intersects()&lt;/code&gt;, which returns any type of spatial relation.
Other spatial subsetting operations such as &lt;code&gt;st_within()&lt;/code&gt; are more conservative, as shown in &lt;a href=&#34;https://geocompr.robinlovelace.net/spatial-operations.html#topological-relations&#34;&gt;the topological relations section&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;buff_agg = aggregate(x = africa[, &amp;quot;pop&amp;quot;], by = buff, FUN = sum)
buff_agg&lt;/code&gt;&lt;/pre&gt;
&lt;!--
show also tidyverse way, so what you are doing is basically a spatial join and a subsequent aggregation without a grouping variable. Didactically, it might be better to present a grouping variable.
--&gt;
&lt;p&gt;The result, &lt;code&gt;buff_agg&lt;/code&gt;, is a spatial object with the same geometry as &lt;code&gt;by&lt;/code&gt; (the circular buffer in this case) but with an additional variable, &lt;code&gt;pop&lt;/code&gt; reporting summary statistics for all features in &lt;code&gt;x&lt;/code&gt; that intersect with &lt;code&gt;by&lt;/code&gt; (the total population of the countries that touch the buffer in this case).
Plotting the result (with &lt;code&gt;plot(buff_agg)&lt;/code&gt;) shows that the operation does not really make sense:
The figure below shows a population of over half a billion people mostly located in a giant circle floating off the west coast of Africa!&lt;/p&gt;
&lt;p&gt;The results of the spatial aggregation exercise presented in this figure are unrealistic for three reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;People do not live in the sea (the geometry of the aggregating object is not appropriate for the geometry target object).&lt;/li&gt;
&lt;li&gt;This method would â€˜double countâ€™ countries whose borders cross aggregating polygons when multiple, spatially contiguous, features are used as the aggregating object.&lt;/li&gt;
&lt;li&gt;It is wrong to assume that all the people living in countries that &lt;em&gt;touch&lt;/em&gt; the buffer reside &lt;em&gt;within&lt;/em&gt; it (the default spatial operator &lt;code&gt;st_intersects()&lt;/code&gt; is too â€˜greedyâ€™). The most extreme example of this is Algeria, the most northerly country selected:
the spatial aggregation operation assumes that all 39 million Algerian citizens reside in the tiny southerly tip that is within the circular buffer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A number of methods can be used to overcome these issues, and generate a more realistic population attributed to the circular buffer illustrated in the above figure.
The simplest of these is to convert the country polygons into points representing their &lt;em&gt;geographic centroids&lt;/em&gt; before aggregation.
&lt;!-- Todo: reference section where we demonstrate geographic centroid generation --&gt;
This would ensure that any spatially contiguous aggregating object covering the target object (the Earth in this case) would result in the same total: there would be no double counting.
The estimated total population residing within the study area would be more realistic if geographic centroids were used.
(The centroid of Algeria, for example, is far outside the aggregating buffer.)&lt;/p&gt;
&lt;p&gt;Except in cases where the number of target features per aggregating feature is very large, or where the aggregating object is &lt;em&gt;spatially congruent&lt;/em&gt; with the target, using centroids can also lead to errors due to boundary effects:
imagine a buffer that covers a large area but contains no centroids.
These issues can be tackled when aggregating areal target data with areal interpolation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Recall
attribute subsetting can also be done in base R with &lt;code&gt;africa_wgs = world[world$continent == &#34;Africa&#34;, ]&lt;/code&gt;.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;â†©ï¸Ž&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>